<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    
    <meta name="Generator" content="iWeb 3.0.4" />
    <meta name="iWeb-Build" content="local-build-20120303" />
    <meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7" />
    <meta name="viewport" content="width=700" />
    <title>PLASMA</title>
    <link rel="stylesheet" type="text/css" media="screen,print" href="PLASMA_files/PLASMA.css" />
    <!--[if lt IE 8]><link rel='stylesheet' type='text/css' media='screen,print' href='PLASMA_files/PLASMAIE.css'/><![endif]-->
    <!--[if gte IE 8]><link rel='stylesheet' type='text/css' media='screen,print' href='Media/IE8.css'/><![endif]-->
    <script type="text/javascript" src="Scripts/iWebSite.js"></script>
    <script type="text/javascript" src="Scripts/Widgets/SharedResources/WidgetCommon.js"></script>
    <script type="text/javascript" src="Scripts/Widgets/Navbar/navbar.js"></script>
    <script type="text/javascript" src="PLASMA_files/PLASMA.js"></script>
  </head>
  <body style="background: rgb(255, 255, 255); margin: 0pt; " onload="onPageLoad();" onunload="onPageUnload();">
    <div style="text-align: center; ">
      <div style="margin-bottom: 0px; margin-left: auto; margin-right: auto; margin-top: 0px; overflow: hidden; position: relative; word-wrap: break-word;  background: rgb(255, 255, 255); text-align: left; width: 700px; " id="body_content">
        <div style="margin-left: 0px; position: relative; width: 700px; z-index: 0; " id="nav_layer">
          <div style="height: 0px; line-height: 0px; " class="bumper"> </div>
          <div class="com-apple-iweb-widget-navbar flowDefining" id="widget0" style="margin-left: 35px; margin-top: 0px; opacity: 1.00; position: relative; width: 630px; z-index: 1; ">
    
            <div id="widget0-navbar" class="navbar">

      
              <div id="widget0-bg" class="navbar-bg">

        
                <ul id="widget0-navbar-list" class="navbar-list">
 <li></li> 
</ul>
                
      
</div>
              
    
</div>
          </div>
          <script type="text/javascript"><!--//--><![CDATA[//><!--
new NavBar('widget0', 'Scripts/Widgets/Navbar', 'Scripts/Widgets/SharedResources', '.', {"path-to-root": "", "navbar-css": ".navbar {\n\tfont-family: Arial, sans-serif;\n\tfont-size: 1em;\n\tcolor: #666;\n\tmargin: 9px 0px 6px 0px;\n\tline-height: 30px;\n}\n\n.navbar-bg {\n\ttext-align: center;\n}\n\n.navbar-bg ul {\n\tlist-style: none;\n\tmargin: 0px;\n\tpadding: 0px;\n}\n\n\nli {\n\tlist-style-type: none;\n\tdisplay: inline;\n\tpadding: 0px 10px 0px 10px;\n}\n\n\nli a {\n\ttext-decoration: none;\n\tcolor: #666;\n}\n\nli a:visited {\n\ttext-decoration: none;\n\tcolor: #666;\n}\n\nli a:hover\r{\r\n \tcolor: #463C3C;\n\ttext-decoration: none;\r}\n\n\nli.current-page a\r{\r\t color: #463C3C;\n\ttext-decoration: none;\n\tfont-weight: bold;\r\r}", "current-page-GUID": "72355728-5522-4B95-BCEA-E49B8EFE1F49", "isCollectionPage": "NO"});
//--><!]]></script>
          <div style="clear: both; height: 0px; line-height: 0px; " class="spacer"> </div>
        </div>
        <div style="height: 73px; margin-left: 0px; position: relative; width: 700px; z-index: 10; " id="header_layer">
          <div style="height: 0px; line-height: 0px; " class="bumper"> </div>
          <div id="id1" style="height: 50px; left: 35px; position: absolute; top: 23px; width: 630px; z-index: 1; " class="style_SkipStroke shape-with-text">
            <div class="text-content style_External_630_50" style="padding: 0px; ">
              <div class="style">
                <p style="padding-bottom: 0pt; padding-top: 0pt; " class="Header">PLASMA</p>
              </div>
            </div>
          </div>
          


          <div style="height: 1px; width: 630px;  height: 1px; left: 35px; position: absolute; top: 3px; width: 630px; z-index: 1; " class="tinyText">
            <div style="position: relative; width: 630px; ">
              <img src="PLASMA_files/shapeimage_1.jpg" alt="" style="height: 1px; left: 0px; position: absolute; top: 0px; width: 630px; " />
            </div>
          </div>
        </div>
        <div style="margin-left: 0px; position: relative; width: 700px; z-index: 5; " id="body_layer">
          <div style="height: 0px; line-height: 0px; " class="bumper"> </div>
          <div style="height: 1px; line-height: 1px; " class="tinyText"> </div>
          <div style="margin-left: 35px; margin-top: 46px; position: relative; width: 630px; z-index: 1; " class="style_SkipStroke_1 shape-with-text flowDefining">
            <div class="text-content style_External_630_6381" style="padding: 0px; ">
              <div class="style">
                <p style="padding-top: 0pt; " class="paragraph_style">Introduction<br /></p>
                <p class="paragraph_style_1">PLASMA is a combination of virtual machine and assembler/compiler matched closely to the 6502 architecture.  It is an attempt to satisfy a few challenges surrounding code size, efficient execution, small runtime and fast just-in-time compilation.  By architecting a unique bytecode that maps nearly one-to-one to the higher level representation, the compiler/assembler can be very simple and execute quickly on the Apple II for a self-hosted environment.  A modular approach provides for incremental development and code reuse.  Different projects have led to the architecture of PLASMA, most notably Apple Pascal, FORTH, and my own Java VM for the 6502, VM02. Each has tried to map a generic VM to the 6502 with varying levels of success.  Apple Pascal, based on the USCD Pascal using the p-code interpreter, was a very powerful system and ran fast enough on the Apple II to be interactive but didn't win any speed contests. FORTH was the poster child for efficiency and obtuse syntax. Commonly referred to as a write only language, it was difficult to come up to speed as a developer, especially when using other's code. My own project in creating a Java VM for the Apple II uncovered the folly of shoehorning a large system into something never intended to run 32 bit applications.<br /></p>
                <p class="paragraph_style_1"><br /></p>
                <p class="paragraph_style">Low Level Implementation<br /></p>
                <p class="paragraph_style_1">Both the Pascal and Java VMs used a bytecode to hide the underlying CPU architecture and offer platform agnostic application execution. The application and tool chains were easily moved from platform to platform by simply writing a bytecode interpreter and small runtime to translate the higher level constructs to the underlying hardware. The performance of the system was dependent on the actual hardware and efficiency of the interpreter. Just-in-time compilation wasn't really an option on small, 8 bit systems. FORTH, on the other hand, was usually implemented as a threaded interpreter. A threaded interpreter will use the address of functions to call as the code stream instead of a bytecode, eliminating one level of indirection with a slight increase in code size.  The threaded approach can be made faster at the expense of another slight increase in size by inserting an actual Jump SubRoutine opcode before each address, thus removing the interpreter's inner loop altogether.  <br /></p>
                <p class="paragraph_style_1"><br /></p>
                <p class="paragraph_style_1">All three systems were implemented using stack architecture.  Pascal and Java were meant to be compiled high level languages, using a stack machine as a simple compilation target.  FORTH was meant to be written directly as a stack oriented language, similar to RPN on HP calculators. The 6502 is a challenging target due to it's unusual architecture so writing a bytecode interpreter for Pascal and Java results in some inefficiencies and limitations.  FORTH's inner interpreter loop on the 6502 tends to be less efficient than most other CPUs.  Another difference is how each system creates and manipulates it's stack. Pascal and Java use the 6502 hardware stack for all stack operations. Unfortunately the 6502 stack is hard-limited to 256 bytes. However, in normal usage this isn't too much of a problem as the compilers don't put undue pressure on the stack size by keeping most values in global or local variables.  FORTH creates a small stack using a portion of the 6502's zero page, a 256 byte area of low memory that can be accessed with only a byte address and indexed using either of the X or Y registers. With zero page, the X register can be used as an indexed, indirect address and the Y register can be used as an indirect, indexed address.<br /></p>
                <p class="paragraph_style_1"><br /></p>
                <p class="paragraph_style_2">A New Approach<br /></p>
                <p class="paragraph_style_1">PLASMA takes an approach that uses the best of all the above implementations to create a unique, powerful and efficient platform for developing new applications on the Apple II.  One goal was to create a very small VM runtime, bytecode interpreter, and module loader that could adjust the code size vs. performance optimizations to allow for interpreted code, threaded code, or efficiently compiled native code.  The decision was made early on to implement a stack based architecture duplicating the approach taken by FORTH.  Space in the zero page would be assigned to a 16 bit, 32 element evaluation stack, indexed by the X register.  The stack is purposely not split between low and high values so as to allow reading and writing addresses stored directly on the stack.  The trade off is that the stack pointer has to be incremented and decremented by two for every push/pop operation.  A simple compiler was written so that higher level constructs could be used and global/local variables would hold values instead of using clever stack manipulation.  Function/procedure frames would allow for local variables, but with a limitation - the frame could be no larger than 256 bytes.  By enforcing this limitation, the function frame could easily be accessed through a frame pointer value in zero page, indexed by the Y register.  The call stack uses the 6502's hardware stack resulting in the same 256 byte limitation imposed by the hardware.  However, this limitation could be lifted by extending the call sequence to save and restore the return address in the function frame. This was not done initially for performance reasons and simplicity of implementation.  One of the goals of PLASMA was to allow for intermixing of functions implemented as bytecode, threaded code, or native code.  Taking a page from the FORTH play book, a function call is implemented as a native subroutine call to an address. If the function is in bytecode, the first thing it does is call back into the interpreter to execute the following bytecode.  Functions can be selectively expanded as bytecode, threaded code, or natively compiled, all at load time.  Threaded code expands to about 3X the size of bytecode with about 3X the performance.  Native code is about 5X-10X the size with a significant improvement in performance.  The native code compiler uses a strategy of caching the Top-Of-Stack value in the Y and A registers of the 6502.  The compiler also tracks the TOS pointer and adjusts the address accordingly to avoid actual manipulation of the X register. The X register in effect becomes the frame pointer for the evaluation stack.  Function call parameters are pushed onto the evaluation stack in order they are written. The first operation inside of the function call is to pull the parameters off the evaluation stack and put them in local frame storage. Function callers and callees must agree on the number of parameters to avoid stack underflow/overflow.  All functions return a value on the evaluation stack regardless of it being used or not.  Lastly, PLASMA is not a typed language. Just like assembly, any value can represent a character, integer, or address. It's the programmer's job to know the type. Only bytes and words are known to PLASMA. Bytes are unsigned 8 bit quantities, words are signed 16 bit quantities. All stack operations involve 16 bits of precision.<br /></p>
                <p class="paragraph_style_1"><br /></p>
                <p class="paragraph_style_1">The PLASMA low level operations are defined as:<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_4">OP<span class="style_1">                      </span>Description<span class="style_1"><br /></span></p>
                <p class="paragraph_style_5">ZERO   push zero on the stack<br /></p>
                <p class="paragraph_style_5">DROP   drop top stack value<br /></p>
                <p class="paragraph_style_5">DUP    duplicate top stack value<br /></p>
                <p class="paragraph_style_5">OVER   duplicate next from top stack value<br /></p>
                <p class="paragraph_style_5">SWAP   swap two topmost stack values<br /></p>
                <p class="paragraph_style_5">ADD    add top two values, leave result on top<br /></p>
                <p class="paragraph_style_5">SUB    subtract next from top from top, leave result on top<br /></p>
                <p class="paragraph_style_5">MUL    multiply two topmost stack values, leave result on top<br /></p>
                <p class="paragraph_style_5">DIV    divide next from top by top, leave result on top<br /></p>
                <p class="paragraph_style_5">MOD    divide next from top by top, leave remainder on top<br /></p>
                <p class="paragraph_style_5">INCR   increment top of stack<br /></p>
                <p class="paragraph_style_5">DECR   decrement top of stack<br /></p>
                <p class="paragraph_style_5">NEG    negate top of stack<br /></p>
                <p class="paragraph_style_5">COMP   compliment top of stack<br /></p>
                <p class="paragraph_style_5">BAND   bit wise AND top two values, leave result on top<br /></p>
                <p class="paragraph_style_5">IOR    bit wise inclusive OR top two values, leave result on top<br /></p>
                <p class="paragraph_style_5">XOR    bit wise exclusive OR top two values, leave result on top<br /></p>
                <p class="paragraph_style_5">NOT    logical NOT of top of stack<br /></p>
                <p class="paragraph_style_5">LOR    logical OR top two values, leave result on top<br /></p>
                <p class="paragraph_style_5">LAND   logical AND top two values, leave result on top<br /></p>
                <p class="paragraph_style_5">SHL    shift left next from top by top, leave result on top<br /></p>
                <p class="paragraph_style_5">SHR    shift right next from top by top, leave result on top<br /></p>
                <p class="paragraph_style_5">IDXB   add top of stack to next from top, leave result on top<br /></p>
                <p class="paragraph_style_5">IDXW   add 2X top of stack to next from top, leave result on top<br /></p>
                <p class="paragraph_style_5">LAA    load absolute address<br /></p>
                <p class="paragraph_style_5">LLA    load local address from frame offset<br /></p>
                <p class="paragraph_style_5">CB     constant byte<br /></p>
                <p class="paragraph_style_5">CW     constant word<br /></p>
                <p class="paragraph_style_5">LB     load byte from top of stack address<br /></p>
                <p class="paragraph_style_5">LW     load word from top of stack address<br /></p>
                <p class="paragraph_style_5">LLB    load byte from frame offset<br /></p>
                <p class="paragraph_style_5">LLW    load word from frame offset<br /></p>
                <p class="paragraph_style_5">LAB    load byte from absolute address<br /></p>
                <p class="paragraph_style_5">LAW    load word from absolute address<br /></p>
                <p class="paragraph_style_5">SB     store top of stack byte into next from top address<br /></p>
                <p class="paragraph_style_5">SW     store top of stack word into next from top address<br /></p>
                <p class="paragraph_style_5">SLB    store top of stack into local byte at frame offset<br /></p>
                <p class="paragraph_style_5">SLW    store top of stack into local word at frame offset<br /></p>
                <p class="paragraph_style_5">SAB    store top of stack into byte at absolute address<br /></p>
                <p class="paragraph_style_5">SAW    store top of stack into word at absolute address<br /></p>
                <p class="paragraph_style_5">DLB    duplicate top of stack into local byte at frame offset<br /></p>
                <p class="paragraph_style_5">DLW    duplicate top of stack into local word at frame offset<br /></p>
                <p class="paragraph_style_5">DAB    duplicate top of stack into byte at absolute address<br /></p>
                <p class="paragraph_style_5">DAW    duplicate top of stack into word at absolute address<br /></p>
                <p class="paragraph_style_5">BRLT   branch next from top less than top<br /></p>
                <p class="paragraph_style_5">BRGT   branch next from top greater than top<br /></p>
                <p class="paragraph_style_5">BREQ   branch next from top equal to top<br /></p>
                <p class="paragraph_style_5">BRNE   branch next from top not equal to top<br /></p>
                <p class="paragraph_style_5">ISEQ   if next from top is equal to top, set top true<br /></p>
                <p class="paragraph_style_5">ISNE   if next from top is not equal to top, set top true<br /></p>
                <p class="paragraph_style_5">ISGT   if next from top is greater than top, set top true<br /></p>
                <p class="paragraph_style_5">ISLT   if next from top is less than top, set top true<br /></p>
                <p class="paragraph_style_5">ISGE   if next from top is greater than or equal to top, set top true<br /></p>
                <p class="paragraph_style_5">ISLE   if next from top is less than or equal to top, set top true<br /></p>
                <p class="paragraph_style_5">BRFLS  branch if top of stack is zero<br /></p>
                <p class="paragraph_style_5">BRTRU  branch if top of stack is non-zero<br /></p>
                <p class="paragraph_style_5">JUMP   jump to address<br /></p>
                <p class="paragraph_style_5">IJMP   jump to address on stack top<br /></p>
                <p class="paragraph_style_5">CALL   sub routine call with stack parameters<br /></p>
                <p class="paragraph_style_5">ICAL   sub routine call to address on stack top with stack parameters<br /></p>
                <p class="paragraph_style_5">ENTER  allocate frame size and copy stack parameters to local frame<br /></p>
                <p class="paragraph_style_5">LEAVE  deallocate frame and return from sub routine call <br /></p>
                <p class="paragraph_style_5">RET    return from sub routine call<br /></p>
                <p class="paragraph_style_5">EXIT   exit back to ProDOS<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_1"><br /></p>
                <p class="paragraph_style">PLASMA Compiler/Assembler<br /></p>
                <p class="paragraph_style_3">Although the low-level operations could easily by coded by hand, they were chosen to be an easy target for a simple compiler. Think along the lines of an advanced assembler or stripped down C compiler ( C--).  Taking concepts from BASIC, Pascal, C and assembler, the PLASMA compiler is simple yet expressive.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Comments are allowed throughout the source, starting with the ‘;’ character.  The rest of the line is ignored.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">; Data and text buffer constants<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Hexadecimal constants are preceded with a ‘$’ to identify them as such.  <br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">$C030 ; Speaker address<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_4">Constants, Variables and Functions<br /></p>
                <p class="paragraph_style_3">The source code of a PLASMA module first defines constants, variables and data.  Constants must be initialized with a value.  Variables can have sizes associated with them to declare storage space.  Data can be declared with or without a variable name associated with it.  Arrays, tables, strings and any predeclared data can be created and accessed in multiple ways.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">;<br /></p>
                <p class="paragraph_style_5">; Constants used for hardware and flags<br /></p>
                <p class="paragraph_style_5">;<br /></p>
                <p class="paragraph_style_5">const speaker     = $C030<br /></p>
                <p class="paragraph_style_5">const changed     = 1<br /></p>
                <p class="paragraph_style_5">const insmode     = 2<br /></p>
                <p class="paragraph_style_5">;<br /></p>
                <p class="paragraph_style_5">; Array declaration of screen row addresses<br /></p>
                <p class="paragraph_style_5">;<br /></p>
                <p class="paragraph_style_5">word  txtscrn[]   = [$0400,$0480,$0500,$0580,$0600,$0680,$0700,$0780]<br /></p>
                <p class="paragraph_style_5">word              = [$0428,$04A8,$0528,$05A8,$0628,$06A8,$0728,$07A8]<br /></p>
                <p class="paragraph_style_5">word              = [$0450,$04D0,$0550,$05D0,$0650,$06D0,$0750,$07D0]<br /></p>
                <p class="paragraph_style_5">;<br /></p>
                <p class="paragraph_style_5">; Misc global variables<br /></p>
                <p class="paragraph_style_5">;<br /></p>
                <p class="paragraph_style_5">byte  flags       = 0<br /></p>
                <p class="paragraph_style_5">word  numlines    = 0<br /></p>
                <p class="paragraph_style_5">byte  cursx, cursy<br /></p>
                <p class="paragraph_style_5">word  cursrow, scrntop, cursptr<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Variables can have optional brackets; empty brackets don’t reserve any space for the variable but are useful as a label for data that is defined following the variable.  Brackets with a constant inside defines a minimum size reserved for the variable.  Any data following the variable will take at least the amount of reserved space, but potentially more.<br /></p>
                <p class="paragraph_style_3">Strings are defined like Pascal strings, a length byte followed by the string characters so they can be a maximum of 255 characters long.  Strings can only appear in the variable definitions of a module.  String constants can’t be used in expressions or statements.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">;<br /></p>
                <p class="paragraph_style_5">; An initialized string of 64 characters<br /></p>
                <p class="paragraph_style_5">;<br /></p>
                <p class="paragraph_style_5">byte txtfile[64] = &quot;UNTITLED&quot;<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Functions are defined after all constants, variables and data.  Functions can be forward declared with a <span class="style_2">func</span> type in the constant and variable declarations.  Functions have optional parameters and always return a value.  By using one of three function declarations (<span class="style_2">def</span>, <span class="style_2">deft</span> and <span class="style_2">defn</span>) you can have the function loaded as interpreted bytecode, threaded calls into the interpreter, or natively compiled code.  There are space and time tradeoffs between the three choices.  Bytecode is the best choice for the majority of functions.  It has decent performance and is extremely compact.  Threaded code would be the choice for functions that are called often but are not leaf routines, i.e. they themselves call other functions.  Native code is a good choice for small, leaf functions that are called often and need the highest performance.  Simply altering the definition is all that is required to set the function code implementation.  Functions can have their own variable declarations.  However, unlike the global declarations, no data can be predeclared, only storage space.  There is also a limit of 256 bytes of local storage.  Each parameter takes two bytes of local storage, plus two bytes for the previous frame pointer.  If a function has no parameters or local variables, no local frame will be created, improving performance.  A function can specify a value to return.  If no return value is specified, a default of 0 will be returned.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">After functions are defined, the main code for the module follows.  There is no option to declare how the main code is loaded - it is always bytecode.  The last statement in the module must be <span class="style_2">done</span>, or else a compile error is issued.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">There are four basic types of data that can be manipulated: constants, variables, addresses, and functions.  Memory can only be read or written as either a byte or a word.  Bytes are unsigned 8 bit quantities, words are signed 16 bit quantities.  Everything on the evaluation stack is treated as a word.  Other than that, any value can be treated as a pointer, address, function, character, integer, etc.  There are convenience operations in PLASMA to easily manipulate addresses and expressions as pointers, arrays, structures, functions, or combinations thereof.  If a variable is declared as a byte, it can be accessed as a simple, single dimension byte array by using brackets to indicate the offset.  Any expression can calculate the indexed offset.  A word variable can be accessed as a word array in the same fashion.  In order to access expressions or constants as arrays, a type identifier has to be inserted before the brackets.  a ‘.’ character denotes a <span class="style_2">byte</span> type, a ‘:’ character denotes a <span class="style_2">word</span> type.  Along with brackets to calculate an indexed offset, a constant can be used after the ‘.’ or ‘:’ and will be added to the base address.  The constant can be a defined <span class="style_2">const</span> to allow for structure style syntax.  If the offset is a known constant, using the constant offset is a much more efficient way to address the elements over an array index.  Multidimensional arrays are treated as arrays of array pointers.  Multiple brackets can follow the ‘.’ or ‘:’ type identifier, but all but the last index will be treated as a pointer to an array.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">word hgrscan[] = [$2000,$2400,$2800,$2C00,$3000,$3400,$3800,$3C00]<br /></p>
                <p class="paragraph_style_5">word           = [$2080,$2480,$2880,$2C80,$3080,$3480,$3880,$3C80]<br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_5">hgrscan:[yscan][xscan] = fillval<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Values can be treated as pointers by preceding them with a ‘^’ for byte pointers, ‘*’ for word pointers.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">strlen = ^(srcstr)<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Addresses of variables and functions can be taken with a preceding ‘@’, address-of operator. Parenthesis can surround an expression to be used as a pointer, but not address-of.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Functions can have optional parameters when called.  Defined functions without parameters can be called simply:<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">def redraw<br /></p>
                <p class="paragraph_style_5">    cursoff<br /></p>
                <p class="paragraph_style_5">    drawscrn(scrntop, scrnleft)<br /></p>
                <p class="paragraph_style_5">    curson<br /></p>
                <p class="paragraph_style_5">end<br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_5">redraw<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Functions with parameters or expressions to be used as a function address to call must use parenthesis, even if empty.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">word keyin<br /></p>
                <p class="paragraph_style_5">byte key<br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_5">keyin = @keyin2plus ; address-of keyin2plus function<br /></p>
                <p class="paragraph_style_5">key   = (keyin)()<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_4">Expressions and Statements<br /></p>
                <p class="paragraph_style_3">Expressions are algebraic.  Data is free-form, but all operations on the evaluation stack use 16 bits of precision with the exception of byte load and stores.  A stand-alone expression will be evaluated and read from or called.  This allows for easy access to the Apple’s soft switches and other memory mapped hardware. The value of the expression is dropped.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">const speaker=$C030<br /></p>
                <p class="paragraph_style_5">^speaker ; click speaker<br /></p>
                <p class="paragraph_style_5"> <br /></p>
                <p class="paragraph_style_5">close(refnum)<br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_3">More complex expressions can be built up using algebraic unary and binary operations.<br /></p>
                <p class="paragraph_style_1"><br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_4">OP<span class="style_1">        </span>Unary Operation<span class="style_1"><br /></span></p>
                <p class="paragraph_style_5"> ^     byte pointer<br /></p>
                <p class="paragraph_style_5"> *     word pointer<br /></p>
                <p class="paragraph_style_5"> @     address of<br /></p>
                <p class="paragraph_style_5"> -     negate<br /></p>
                <p class="paragraph_style_5"> #     bitwise compliment<br /></p>
                <p class="paragraph_style_5"> !     logical NOT<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_4">OP<span class="style_1">        </span>Binary Operation<span class="style_1"><br /></span></p>
                <p class="paragraph_style_5"> *     multiply<br /></p>
                <p class="paragraph_style_5"> /     divide<br /></p>
                <p class="paragraph_style_5"> %     modulo<br /></p>
                <p class="paragraph_style_5"> +     add<br /></p>
                <p class="paragraph_style_5"> -     subtract<br /></p>
                <p class="paragraph_style_5"> &lt;&lt;    shift left<br /></p>
                <p class="paragraph_style_5"> &gt;&gt;    shift right<br /></p>
                <p class="paragraph_style_5"> &amp;     bitwise AND<br /></p>
                <p class="paragraph_style_5"> ?     bitwise OR<br /></p>
                <p class="paragraph_style_5"> ^     bitwise XOR<br /></p>
                <p class="paragraph_style_5"> ==    equals<br /></p>
                <p class="paragraph_style_5"> &lt;&gt;    not equal<br /></p>
                <p class="paragraph_style_5"> &gt;=    greater than or equal<br /></p>
                <p class="paragraph_style_5"> &gt;     greater than<br /></p>
                <p class="paragraph_style_5"> &lt;=    less than or equal<br /></p>
                <p class="paragraph_style_5"> &lt;     less than<br /></p>
                <p class="paragraph_style_5">OR     logical OR<br /></p>
                <p class="paragraph_style_5">AND    logical AND<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_1"><br /></p>
                <p class="paragraph_style_3">Statements are built up from expressions and control flow keywords.  Simplicity of syntax took precedence over flexibility and complexity.  The simplest statement is the basic assignment using ‘=’.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">byte numchars<br /></p>
                <p class="paragraph_style_5">numchars = 0<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Expressions can be built up with constants, variables, function calls, addresses, and pointers/arrays.  Comparison operators evaluate to 0 or -1 instead of the more traditional 0 or 1.  The use of -1 allows binary operations to be applied to other non-zero values and still retain a non-zero result.  Any conditional tests check only for zero and non-zero values.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">Control structures affect the flow of control through the program.  There are conditional and looping constructs.  The most widely used is probably the <span class="style_2">if/elsif/else/fin</span> construct.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">if ^pushbttn3 &lt; 128<br /></p>
                <p class="paragraph_style_5">    if key == $C0<br /></p>
                <p class="paragraph_style_5">        key = $D0 ; P<br /></p>
                <p class="paragraph_style_5">    elsif key == $DD<br /></p>
                <p class="paragraph_style_5">        key = $CD ; M<br /></p>
                <p class="paragraph_style_5">    elsif key == $DE<br /></p>
                <p class="paragraph_style_5">        key = $CE ; N<br /></p>
                <p class="paragraph_style_5">    fin<br /></p>
                <p class="paragraph_style_5">else<br /></p>
                <p class="paragraph_style_5">   key = key ? $E0<br /></p>
                <p class="paragraph_style_5">fin<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">The <span class="style_2">case/of/otherwise/merge</span> statement is similar to the <span class="style_2">if/elsif/else/fin</span> construct except that it is more efficient.  It selects one path based on the evaluated expressions, then merges the code path back together at the end.  However only the case value is compared against a list of expressions.  The expressions do not need to be constants, they can be any valid expression.  The list of expressions is evaluated in order, so for efficiency sake, place the most common cases earlier in the list.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">case keypressed<br /></p>
                <p class="paragraph_style_5">    of keyarrowup<br /></p>
                <p class="paragraph_style_5">        cursup<br /></p>
                <p class="paragraph_style_5">    of keyarrowdown<br /></p>
                <p class="paragraph_style_5">        cursdown<br /></p>
                <p class="paragraph_style_5">    of keyarrowleft<br /></p>
                <p class="paragraph_style_5">       cursleft<br /></p>
                <p class="paragraph_style_5">    of keyarrowright<br /></p>
                <p class="paragraph_style_5">        cursright<br /></p>
                <p class="paragraph_style_5">    of keyctrlx<br /></p>
                <p class="paragraph_style_5">        cutline<br /></p>
                <p class="paragraph_style_5">    of keyctrlv<br /></p>
                <p class="paragraph_style_5">        pasteline<br /></p>
                <p class="paragraph_style_5">    of keyescape<br /></p>
                <p class="paragraph_style_5">        cursoff<br /></p>
                <p class="paragraph_style_5">        cmdmode<br /></p>
                <p class="paragraph_style_5">        redraw<br /></p>
                <p class="paragraph_style_5">    otherwise<br /></p>
                <p class="paragraph_style_5">        bell<br /></p>
                <p class="paragraph_style_5">merge<br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_3">The most common looping statement is the <span class="style_2">for/next</span> construct.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">for xscan = 0 to 19<br /></p>
                <p class="paragraph_style_5">    (scanptr):[xscan] = val<br /></p>
                <p class="paragraph_style_5">next<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">The <span class="style_2">for/next</span> statement will efficiently increment or decrement a variable form the starting value to the ending value.  The increment/decrement amount can be set with the <span class="style_2">step</span> option after the ending value; the default is one.  If the ending value is less than the starting value, use <span class="style_2">downto</span> instead of <span class="style_2">to</span> to progress in the negative direction.  Only use positive <span class="style_2">step</span> values.  The <span class="style_2">to</span> or <span class="style_2">downto</span> will add or subtract the <span class="style_2">step</span> value appropriately.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">for i = heapmapsz - 1 downto 0<br /></p>
                <p class="paragraph_style_5">    if sheapmap.[i] &lt;&gt; $FF<br /></p>
                <p class="paragraph_style_5">        mapmask = szmask<br /></p>
                <p class="paragraph_style_5">    fin<br /></p>
                <p class="paragraph_style_5">next<br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_3"><span class="style_2">while/loop</span> statements will continue looping as long as the <span class="style_2">while</span> expression is non-zero.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">while !(mask &amp; 1)<br /></p>
                <p class="paragraph_style_5">    addr = addr + 16<br /></p>
                <p class="paragraph_style_5">    mask = mask &gt;&gt; 1<br /></p>
                <p class="paragraph_style_5">loop<br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_3">Lastly, the <span class="style_2">repeat/until</span> statement will continue looping as long as the <span class="style_2">until</span> expression is zero.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">repeat<br /></p>
                <p class="paragraph_style_5">    txtbuf   = read(refnum, @txtbuf + 1, maxlnlen)<br /></p>
                <p class="paragraph_style_5">    numlines = numlines + 1<br /></p>
                <p class="paragraph_style_5">until txtbuf == 0 or numlines == maxlines<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_4">Runtime<span class="style_1"><br /></span></p>
                <p class="paragraph_style_3">PLASMA includes a very minimal runtime that nevertheless provides a great deal of functionality to the system.  Two system calls are provided to access native 6502 routines (usually in ROM) and ProDOS.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3"><span class="style_2">call6502(aReg, xReg, yReg, statusReg, addr)</span> returns a pointer to a four byte structure containing the A,X,Y and STATUS register results.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">const xreg = 1<br /></p>
                <p class="paragraph_style_5">const getlin = $FD6A<br /></p>
                <p class="paragraph_style_5">numchars = (call6502(0, 0, 0, 0, getlin)).xreg ; return char count in X reg<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3"><span class="style_2">prodos(cmd, params)</span>calls ProDOS, returning the status value.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">def read(refnum, buff, len)<br /></p>
                <p class="paragraph_style_5">    byte params[8]<br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_5">    params.0 = 4<br /></p>
                <p class="paragraph_style_5">    params.1 = refnum<br /></p>
                <p class="paragraph_style_5">    params:2 = buff<br /></p>
                <p class="paragraph_style_5">    params:4 = len<br /></p>
                <p class="paragraph_style_5">    perr     = prodos($CA, @params)<br /></p>
                <p class="paragraph_style_5">    return params:6<br /></p>
                <p class="paragraph_style_5">end<br /></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_3"><span class="style_2">cout(char), prstr(string), prstrz(stringz)</span> are handy utility routines for printing to the standard Apple II COUT routine.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_5">cout('.')<br /></p>
                <p class="paragraph_style_5">byte okstr[] = &quot;OK&quot;<br /></p>
                <p class="paragraph_style_5">prstr(@okstr)<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3"><span class="style_2">memset(val16, addr, len)</span> will fill memory with a 16 bit value.  <span class="style_2">memcpy(srcaddr, dstaddr, len)</span> will copy memory from one address to another, taking care to copy in the proper direction.<span class="style_2"><br /></span></p>
                <p class="paragraph_style_5"><br /></p>
                <p class="paragraph_style_5">byte nullstr[] = &quot;&quot;<br /></p>
                <p class="paragraph_style_5">memset(@nullstr, strlinbuf, maxfill * 2) ; fill line buff with pointer to null string<br /></p>
                <p class="paragraph_style_5">memcpy(strptr + ofst + 1, scrnptr, numchars)<br /></p>
                <p class="paragraph_style_6"><br /></p>
                <p class="paragraph_style_4">Implementation Details<br /></p>
                <p class="paragraph_style_3">The original design concept was to create an efficient, flexible, and expressive environment for building applications directly on the Apple II.  Choosing a stack based architecture was easy after much experience with other stack based implementations.  It also makes the compiler simple to implement.  The first take on the stack architecture was to make it a very strict stack architecture in that everything had to be on the stack.  The only opcode with operands was the CONSTANT opcode.  This allowed for a very small bytecode interpreter and a very easy compile target.  However, only when adding an opcode with operands that would greatly improved performance, native code generation or code size was it done.  The opcode table grew slowly over time but still retains a small runtime interpreter with good native code density.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">The ultimate target is to have a complete IDE available for the Apple II.  However, the bootstrapping process of creating a new language and VM was eased by first writing the code for cross development using the cc65 assembler/linker toolchain and a PLASMA compiler written in C that spits out cc65 compatible assembly code.  Debugging and development centered around Apple II emulation before testing on real hardware.  In order to fully exercise the concepts around the compiler and VM architecture, a 40 column ProDOS text editor was written (filling a need I’ve had for some time).  The cross development tools can only operate on one PLASMA source file to create a ProDOS .SYS file loading at $2000.  The editor source file is starting to get a little unwieldy at just over 1100 lines.  However, the goals were satisfied to create a language capable of high level development with compact and fast code generation.  The editor + bytecode interpreter is just under 9.5K and still has 28K available for the text buffer after disk buffers and line buffers are allocated.  To develop this editor using assembly would have taken much longer than the week it took using PLASMA (including compiler/VM debugging) and is smaller than a comparable native C compiler would generate.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3">The next step is to write the PLASMA compiler in PLASMA itself to self-host on the Apple II.  Along with being self-hosted, a more flexible module file format will be created to allow loading modules on demand and putting the bytecode interpreter and module loader in the RAM card memory, thus freeing up much needed main memory.<br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_3"><br /></p>
                <p class="paragraph_style_7">Links<span class="style_1"><br /></span></p>
                <p class="paragraph_style_4"><a onclick="window.open(this.href); return false;" title="http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/plasma/" href="http://vm02.cvs.sourceforge.net/viewvc/vm02/vm02/plasma/" onkeypress="window.open(this.href); return false;" class="style_1">VM02 Sourceforge Project (plasma directory)</a><br /></p>
                <p class="paragraph_style_3"><a title="http://schmenk.is-a-geek.com/tarfiles/plasma01.dsk" href="http://schmenk.is-a-geek.com/tarfiles/plasma01.dsk">PLASMA v.01 demo disk image</a><br /></p>
              </div>
              <div style="height: 15px; line-height: 15px; " class="tinyText"> </div>
            </div>
          </div>
          


          <div id="id2" style="height: 32px; left: 35px; position: absolute; top: 8px; width: 630px; z-index: 1; " class="style_SkipStroke_2 shape-with-text">
            <div class="text-content graphic_shape_layout_style_default_External_630_32" style="padding: 0px; ">
              <div class="graphic_shape_layout_style_default">
                <p style="padding-bottom: 0pt; padding-top: 0pt; " class="Title">Proto Language ASsembler for Apple</p>
              </div>
            </div>
          </div>
          <div style="height: 0px; line-height: 0px; " class="spacer"> </div>
        </div>
        <div style="height: 150px; margin-left: 0px; position: relative; width: 700px; z-index: 15; " id="footer_layer">
          <div style="height: 0px; line-height: 0px; " class="bumper"> </div>
        </div>
      </div>
    </div>
  </body>
</html>


