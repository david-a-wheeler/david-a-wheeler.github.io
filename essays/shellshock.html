<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Shellshock</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Information about Shellshock">
<meta name="keywords" content="shellshock, bashdoor, bash, timeline, shell, vulnerability">
<meta name="generator" content="vim">
<link rel="stylesheet" type="text/css" href="paper.css">
</head>

<body>

<h1 class="title">Shellshock</h1>
<h2 class="author"><a href="https://dwheeler.com/">David A. Wheeler</a></h2>
<h2 class="date">2025-09-30 (originally 2014-10-02)</h2>


<img align="right" class="logo" width="293" height="165" src="shellshock-logo-addelindh.jpg" alt="Shellshock Vulnerability proposed logo by Andreas Lindh, in part responsible for giving this vulnerability this name">
<!--
Proposed logo posted here:
  https://twitter.com/addelindh/status/514840916692324352
586x330
Unfortunately the licensing information is not made clear, but it
appears to have been developed specifically as a logo for discussing this,
so I'm using it in the way it was intended to be used.
-->

<p>
This paper covers the
<a href="#basics">basics of the Shellshock bash vulnerability</a>,
a discussion on ways to
<a href="#detect-or-prevent">detect or prevent future Shellshock-like vulnerabilities</a>,
a <a href="#timeline">timeline</a> of what happened when, and
some information about the specific <a href="#cves">CVEs</a>
(vulnerability identifiers).
It ends with a few <a href="#conclusions">conclusions</a>.
This paper is part of the
essay suite <a href="learning-from-disaster.html">Learning from Disaster</a>.

<h1 id="basics">Shellshock basics</h1>
<p>
The <i>shellshock</i> vulnerability is a vulnerability in the
widely-used <i>bash</i> command shell.
This vulnerability had a <a href="#impact">huge impact</a>.
Here I will discuss the
<a href="#initial-disclosure">initial disclosure</a>, the
<a href="#bigger">realization that there was a bigger problem</a>,
how to
<a href="#detecting">detect the Shellshock vulnerability</a>,
<a href="#naming">naming Shellshock</a>,
and the general
<a href="#aftermath">aftermath</a>.


<h2 id="impact">Impact</h2>

<p>
The bash shell is widely used in many Unix-like systems,
including Linux-based systems (such as
Red Hat Enterprise Linux, Fedora, CentOS, Debian, and Ubuntu),
*BSDs (such as FreeBSD and NetBSD),
Apple MacOS X,
and Cygwin (which runs on Windows).
Thus, there were many systems that were potentially exploitable.

<p>
Shells are widely used on these systems to process commands,
so there were many ways to potentially exploit Shellshock.
A system is exploitable
if an attacker could find a sequence of events
where the attacker can control the content of an environment variable
<i>and</i> have it sent through a bash shell with the Shellshock vulnerability.
This situation included many systems running CGI web applications
that were invoked via bash or invoked bash subshells,
<a href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man5/sshd_config.5?query=sshd_config">sshd using ForceCommand (to limit access to specific actions)</a>,
and DHCP clients connecting to subverted DHCP servers.

<p>
Whether or not a system was <i>actually</i> exploitable depended on many
low-level details.
Many programs are invoked indirectly via shell scripts,
and those scripts may invoke the default non-interactive shell
(e.g., using <tt>#!/bin/sh</tt>)
or explicitly require bash (e.g., using <tt>#!/bin/bash</tt>).
Many low-level routines (such as <tt>system()</tt>, <tt>popen()</tt>,
<tt>execlp()</tt>,  <tt>execvp()</tt>, and <tt>execvpe()</tt>)
will always or under certain conditions
invoke the default non-interactive shell (which in some cases is bash).
Similarly,
many languages have built-in routines that always or sometimes
invoke the default non-interactive shell.

<p>
Systems often invoke the default non-interactive shell, so systems
with bash as the default non-interactive shell were more likely
to be exploitable than those that used another shell.
For example, systems using Debian and
<a href="https://wiki.ubuntu.com/DashAsBinSh">Ubuntu</a> were
less likely to be exploitable,
because their default non-interactive shell is dash
(which was not vulnerable) instead of bash,
but there were still cases where Debian and Ubuntu systems could be
exploited.
One point of confusion about Debian and Ubuntu is that their default
<i>interactive</i> shell is bash, while their default
<i>non-interactive</i> shell is dash, and it is primarily the
<i>non-interactive</i> shell (aka <tt>/bin/sh</tt>) that increases
the exploitability of the Shellshock vulnerability.
Similarly, Apple MacOS does not use bash in many circumstances, but there
were cases where it could be exploited.
<a href="http://www.all-things-android.com/content/mirbsd-korn-shell-android-shell">Android systems use Linux
but normally use the <tt>MirBSD (mksh) shell</tt></a>,
which was not vulnerable.
Some other systems, like Red Hat Enterprise Linux, CentOS, and Fedora,
do use bash as the default non-interactive shell (<tt>/bin/sh</tt>), and that
increased the likelihood that they could be exploited.

<p>
<a href="http://www.itnews.com.au/News/396197,first-shellshock-botnet-attacks-akamai-us-dod-networks.aspx">Attackers quickly used Shellshock to build a botnet</a>, dubbed wopbot,
that actively scanned and attacked systems
at Akamai and the U.S.  Department of Defense.
<!--
This article: http://www.zdnet.com/yahoo-confirms-servers-infected-but-not-by-shellshock-7000034411/
casts doubt on this:
<a href="http://www.independent.co.uk/life-style/gadgets-and-tech/news/shellshock-romanian-hackers-are-accessing-yahoo-servers-claims-security-expert-9777753.html"><i>The Independent</i> reports that servers for Yahoo!, Lycos, and WinZip were infiltrated</a>.
-->

<p>
It is considered maximally severe on systems where it applies, e.g.,
under the CVSS scoring system it has a maximum score because it is
network exploitable, has low access complexity, does not require authentication
to exploit, and can allow complete control of a vulnerable system
(leading to unauthorized information disclosure, unauthorized modification,
and/or disruption of service).
In addition, bash is very widely deployed, so this maximally-severe
problem applied to a large number of systems.
Finally, the
<a href="#bigger">original fix did <i>not</i> work</a>,
leading to a hurried worldwide effort to develop true fixes
and then deploy them.

<h2 id="initial-disclosure">Initial disclosure</h2>
<p>
Shellshock was discovered by St√©phane Chazelas, reported to its developer and
a few others, and assigned the CVE identifier
<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271">CVE-2014-6271</a>.
The lead developer of bash, Chet Ramey, developed a fix
which was rolled out by major distributors as part of a routine
<a href="https://en.wikipedia.org/wiki/Full_disclosure_%28computer_security%29#Coordinated_disclosure">coordinated disclosure</a>.
<p>
A quick aside on terminology is appropriate here.
Some people use the term &#8220;responsible disclosure&#8221; instead,
but that is a misleading and pejorative term.
<a href="http://www.theregister.co.uk/Print/2011/04/19/microsoft_vulnerability_disclosure_policy/">In 2011 Microsoft switched terminology
from <i>responsible disclosure</i> to <i>coordinated disclosure</i></a>.
I recommend that others do the same.
<!--
However, at first the problem was not fully understood, so the early
patches did not fully solve the problem... making the impact
worse than it would have been otherwise.
-->

<p>
Anyway, the post
<a href="http://seclists.org/oss-sec/2014/q3/650">CVE-2014-6271: remote code execution through bash by Florian Weimer (2014-09-24 17:03:19 +0200)</a>
was one of the first public public disclosures of the problem
as it was then understood.
It explained that (and I am quoting here):
<blockquote>
&#8220;Bash supports exporting not just shell variables, but also shell
functions to other bash instances, via the process environment to
(indirect) child processes.
Current bash versions use an environment
variable named by the function name, and a function definition
starting with &#8220;() {&#8221; in the variable value to propagate function
definitions through the environment.  The vulnerability occurs because
bash does not stop after processing the function definition; it
continues to parse and execute shell commands following the function
definition.  For example, an environment variable setting of
<pre>
    VAR=() { ignored; }; /bin/id
</pre>
will execute /bin/id when the environment is imported into the
bash process...
So far, HTTP requests to CGI scripts have been identified as the major
attack vector.  A typical HTTP request looks like this:
<pre>
     GET /path?query-param-name=query-param-value HTTP/1.1
     Host: www.example.com
     Custom: custom-header-value
</pre>
The CGI specification maps all parts to environment variables.  With
Apache httpd, the magic string &#8220;() {&#8221; can appear in these places:
<ul>
<li>Host (&#8220;www.example.com&#8221;, as REMOTE_HOST)
<li>Header value (&#8220;custom-header-value&#8221;, as HTTP_CUSTOM in this example)
<li>Server protocol (&#8220;HTTP/1.1&#8221;, as SERVER_PROTOCOL)
</ul>
...
The other vector is OpenSSH, either through AcceptEnv variables, TERM
or SSH_ORIGINAL_COMMAND.
Other vectors involving different environment variable set by
additional programs are expected.&#8221;
</blockquote>
<p>
Whether or not a system is exploitable depends on many complex factors;
not <i>every</i> use of CGI made a system exploitable.
See the earlier discussion on its <a href="#impact">impact</a>.
Still, it was a common enough circumstance that many systems
were exploitable.


<h2 id="bigger">Realization of a bigger problem</h2>
<p>
The original understanding, however, turned out to be false.
The repair created by the bash developers stopped parsing at the
closing &#8220;}&#8221; of a function definition, but the bash shell was still
parsing <i>every</i> environment variable that began with the
magic sequence &#8220;<tt>()&nbsp;{</tt>&#8221;.
People noticed and discussed its ramifications in locations such as the:
<ul>
<li><a href="http://oss-security.openwall.org/wiki/mailing-lists/oss-security">oss-security mailing list</a>
(a widely-archived mailing list, also called oss-sec, for
public discussion of security flaws, concepts, and practices
in the Open Source community)
<li><a href="https://lists.gnu.org/mailman/listinfo/bug-bash">bug-bash mailing list</a> (a mailing list used to report and discuss bash bugs)
<li><a href="http://seclists.org/fulldisclosure/">full disclosure mailing list</a>
(a public, vendor-neutral forum for detailed discussion of
vulnerabilities and exploitation techniques)
</ul>
<p>
Security researchers quickly realized that as long as bash continued to
parse untrusted data,
<i>any</i> error in the bash parser (which processed such variables)
could lead to a dangerous security exploit.
Yet the bash parser was <i>never</i> intended to be security-relevant!
Researchers immediately looked for bash parser errors.
Later that day,
<a href="https://twitter.com/taviso/status/514887394294652929">Tavis Ormandy
reported and then tweeted an example of a bug in the bash parser</a>
that could lead to an exploit.
This was assigned <a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-7169">CVE-2014-7169</a>,
and soon afterwards four more bash parser errors were found
(each of which had a CVE identifier assigned).
What had been intended to be a coordinated disclosure had turned into a
<a href="https://en.wikipedia.org/wiki/Full_disclosure_%28computer_security%29">full disclosure</a> process instead.

<p>
At this point one of the advantages of open source software (OSS)
kicked in: People other than
original software developer can examine the software,
propose a solution, or implement that solution.
<a href="http://www.openwall.com/lists/oss-security/2014/09/25/13">Florian Weimer (Red Hat)</a>
quickly posted a patch for bash that counters the attack
in a full and general way.
In this patch, environment variables are <i>only</i> examined for
shell functions if the variable names begin with prefix
&#8220;<tt>BASH_FUNC_</tt>&#8221; and suffix &#8220;<tt>()</tt>&#8221;.
Adding prefixes had been previously suggested by Michal Zalewski;
suffixes were an addition previously suggested by Eric Blake.
Distributions rapidly deployed
broad defenses that eliminated the problem, since they did not need to
wait for the lead bash developer to determine how to fix it upstream.
Red Hat, CentOS, Fedora, Oracle Linux,
Debian, and Ubuntu adopt Florian Weimer&#8217;s
prefix/suffix approach.
<a href="http://support.apple.com/kb/HT6495">Apple&#8217;s later OS X bash update 1.0 includes Florian Weimer&#8217;s approach</a>, with slightly different
prefixes and suffixes
(prefix &#8220;<tt>__BASH_FUNC</tt>&lt;&#8221;
and suffix &#8220;<tt>&gt;()</tt>&#8221;).
In contrast, NetBSD and FreeBSD disabled automatic imports
(so imports must be specifically requested) per a
<a href="http://seclists.org/oss-sec/2014/q3/755">patch proposed by
Christos Zoulas</a>; this also completely eliminates the vulnerability.
<a href="https://blogs.akamai.com/2014/09/environment-bashing.html">Akamai
developed their own emergency patch</a>, which they deployed internally
and made available to others.
Antti Louko and later Solar Designer (Alexander Peslyak)
posted approaches to perform
binary patches (which were handy for patching otherwise unmaintained systems).

<p>
On 2014-09-27 22:50:07 -0400,
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00278.html">Chet Ramey posted bash-4.3 official patch 27 aka &#8220;bash43-027&#8221;
(along with related patches), formally accepting into
mainline (upstream) bash Florian Weimer&#8217;s prefix/suffix approach</a>.
This eliminated the Shellshock problem in the upstream program (bash)
used by everyone else as their baseline.
The official version in bash used the same
prefix &#8220;<tt>BASH_FUNC_</tt>&#8221; that Florian originally proposed,
but changes the suffix from
&#8220;<tt>()</tt>&#8221; to &#8220;<tt>%%</tt>&#8221;.
I think this official bash change
is a mild improvement over Florian&#8217;s original patch;
the sequence &#8220;<tt>%%</tt>&#8221; has no shell metacharacters,
reducing the risk that it will trigger other problems.

<h2 id="detecting">Detecting the Shellshock vulnerability</h2>

<p>
To determine if your version of bash is vulnerable to Shellshock,
run the following <i>refined test</i> on a Unix-like system command line
(this should work on any Bourne or C shell):
<pre>
   env foo='() { echo not patched; }' bash -c foo
</pre>
<p>
This will reply &#8220;<tt>bash: foo: command not found</tt>&#8221;
on a repaired version of bash, while a vulnerable bash
will typically reply &#8220;<tt>not patched</tt>&#8221; instead.
The initial &#8220;<tt>env</tt>&#8221; can be omitted when typing the
command into a POSIX/Bourne shell (including bash, dash, and ash).
If you want to test a bash that is not first in your path,
change <tt>bash</tt> to the full path to the program to test.
<p>
This refined test determines if bash automatically parses function imports
<i>at all</i> when they are in normal environment variables;
a correctly-patched bash must not.
The cause of the Shellshock vulnerability is the inappropriate
parsing of normal environment variables; this should not occur
because some (though not all)
normal environment variables include data provided by attackers.
The refined test works correctly reports that bash is not vulnerable
across many correct solutions,
including any variation of the prefix/suffix change proposed by Florian Weimer,
the elimination of automatic function imports as proposed by Christos Zoulas,
or the elimination of function imports through binary patches
as proposed by Antti Louko and Solar Designer.
It also correctly detects that your version of bash is vulnerable if
it is unpatched or if it only applied the original patch
(the original patch did not fully solve the problem).
Credits: This refined test was
<a href="http://lists.openwall.net/full-disclosure/2014/10/01/10">originally posted by Michal Zalewski</a> and
<a href="http://lists.openwall.net/full-disclosure/2014/10/01/11">refined by Paul Vixie</a>.
This test has been posted other places too, e.g., the
<a href="https://host-project.org/content/are-you-open-being-shell-shocked">HOST project&#8217;s &#8220;Are you Open to Being Shell-Shocked?&#8221;</a>
<!--
this specific test text is
<a href="http://www.openwall.com/lists/oss-security/2014/10/05/7">from
Solar Designer</a>.
-->

<p>
One reader asked me why a slightly different test does <i>not</i>
reliably determine if bash is vulnerable.
He noticed that the following test
produces &#8220;not patched&#8221; on
bash 4.3 with all patches up through patch 30:
<pre>
   env BASH_FUNC_foo%%='() { echo not patched; }' bash -c foo  # bad test
</pre>
<p>
This is true, but not a security vulnerability.
The reason is that on most fixed bash implementations,
<i>only</i> environment variables beginning with a specific prefix
(typically &#8220;BASH_FUNC_&#8221;) and suffix (typically &#8220;%%&#8221;)
are checked for functions to import.
This is not a security vulnerability because attackers cannot choose
the names of the environment variables in correctly-working programs.
If an attacker could set an arbitrary environment variable to an
arbitrary value then they control the program
anyway (e.g., via <tt>PATH</tt> or <tt>LD_PRELOAD</tt>).
Programs that cross security boundaries, such as setuid or setgid programs,
already must
<a href="https://dwheeler.com/secure-class/Secure-Programs-HOWTO/environment-variables.html">extract and erase environment variables</a>.
Since attacker data is only set in specific environment variables
(such as the ones used in the CGI interface), and none of these have
this particular prefix and suffix, they cannot cause any problems.
<!--
Wed, 08 Oct 2014 12:44:34 -0700
From: 	stan at computerfixpro.com
-->

<p>
<a href="https://raw.githubusercontent.com/hannob/bashcheck/master/bashcheck">Hanno B√∂ck developed a more detailed script to determine
whether or not a given bash implementation is vulnerable</a>, including specific tests
for each known CVE.
Perhaps most importantly,
<a href="http://seclists.org/oss-sec/2014/q4/111">it first tests to see if the complete countermeasures are in place; it then tests for specific cases</a>.
However, this is more detailed information than many people need;
this is primarily useful for security researchers and
<a href="http://www.openwall.com/lists/oss-security/2014/10/05/15">distribution vendors</a>.
Similarly, <a href="https://shellshocker.net/">shellshocker.net</a>
posted a long sequence of tests for various specific exploits, yet
their test for exploit 6 (CVE-2014-6278)
as of 2014-10-07 16:00 -0400
is functionally identical to this test and is all that is needed.
<!--
shellshocker.net
Exploit 6 (CVE-2014-6278)
shellshocker='() { echo You are vulnerable; }' bash -c shellshocker
-->

<p>
Unfortunately, early scripts for detecting the Shellshock vulnerability
only detected the original problem as it was originally
understood and reported as CVE-2014-6271.
<a href="https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/">For example, many people used
this script to detect the vulnerability (as it was originally reported)</a>:
<pre>
   env x='() { :;}; echo vulnerable' bash -c "echo this is a test"
</pre>
<p>
However, this version does <i>not</i> detect the full Shellshock vulnerability.
This test only determines if code is run after the closing curly brace,
but bash implementations that pass this test might still force the
the bash parser to directly parse data provided by an attacker.
Since the bash parser was not designed to do this, this
creates a security risk.
<!--
http://www.tomsguide.com/us/shellshock-primer,news-19737.html
on 2014-11-10 led with an image of this early incomplete test,
though the text does not claim it is the complete test.
-->
Some later scripts tested more, but sometimes unnecessarily worried people
because they identified parser errors without first determining
if they were exploitable.

<h2 id="naming">Naming Shellshock</h2>

<p>
<a href="http://seclists.org/oss-sec/2014/q4/92">St√©phane Chazelas proposed
calling vulnerability &#8220;bashdoor&#8221;</a>, but this name did not
catch on.

<p>
Instead, as part of discussion on what to name the vulnerability,
<a href="https://mobile.twitter.com/addelindh/status/514817121101283328">Andreas Lindh proposed &#8220;Shell Schock&#8221; on 2014-09-24 16:42:21 +0000</a>.
Mark Stanislav (who had started the discussion)
quickly commented that this name was a &#8220;good one&#8221;.
Once spelled more conventionally, this name quickly caught on.
<a href="http://blog.erratasec.com/2014/09/bash-bug-as-big-as-heartbleed.html">Robert Graham in &#8220;Bash bug as big as Heartbleed&#8221;</a> added an update,
saying &#8220;I think people are calling this the &#8216;shellshock&#8217; bug.
Still looking for official logo&#8221;.
<a href="https://twitter.com/addelindh/status/514840916692324352">Andreas Lindh then tweeted a proposed logo in response to Robert Graham&#8217;s challenge</a>.
This is confirmed by a tweet where
<a href="https://twitter.com/ErrataRob/status/514919756026351616">Rob Graham credits Andreas Lindh for coining the name Shellshock</a>.
(My thanks to Larry W. Cashdollar who pointed me to this information.)

<h2 id="aftermath">Aftermath</h2>
<p>
This was an extremely bad vulnerability.
Unlike Heartbleed this attack was <i>easy</i> to exploit on vulnerable
systems, and it granted attackers
immediate control of vulnerable systems when successful.
What is worse, the initial understanding of the problem was faulty, so
the carefully-crafted response developed at first
did not fully fix the problem.
<p>
The good news was that there was a rapid response of the various security
researchers and distributors who quickly realized that the original fix
was not enough.
Instead of pretending there was no problem, they quickly identified
solutions and distributed them to their users.
<p>
The biggest issue, as always, is those systems which are not rapidly updated.
Indeed, many systems have no reasonable update process at all!
A big question is how many embedded systems use bash.
Historically embedded systems had limited resources, and thus would
typically include a less-featureful shell like ash or dash.
For example, busybox users would typically use its ash shell, not bash.
However, modern embedded systems often have so much storage space that
they <i>could</i> use a richly-featured shell like bash.
Since embedded systems are rarely updated, or may not even <i>have</i>
an update process, this could be a real problem.
How many embedded systems have bash?
I have no idea.
Thankfully, the aftermath was less than it might have been, probably
because memory-constrained systems tend to include components
with fewer features.
<p>
One intriguing thing about this vulnerability is that journalists
were more adept than in the past
at following developers and researchers as they discussed the problem in
real time. Journalists actively read and referred to
mailing lists, Twitter, and other social media
to track and report what was going on.

<p>
Many looked for similar problems.
For example,
<a href="https://twitter.com/FioraAeterna/status/517791046835920897/">FioraAeterna tweeted on 2014-10-02 an odd behavior of the Microsoft Windows command shell</a>.
In the Microsoft command shell, the commands:
<pre>
   set foo=bar^&amp;ping -n 1 localhost
   echo %foo%
</pre>
will produce &#8220;bar&#8221; followed by an execution of the ping command.
This works because &#8216;^&#8217; escapes special characters,
including the &#8220;&&#8221; (pipeline) symbol.
The second command is effectively
&#8216;echo bar&amp;ping -n 1 localhost&#8217;.
I have personally confirmed that this oddity works in both
<tt>cmd.exe</tt> and <tt>command.exe</tt> on Windows&nbsp;7,
but I expect it to work on practically all Windows systems deployed today.
My thanks to Dale Visser, who told me about this tweet.
Is this exploitable?
I do not currently know of a direct exploit.
This really appears to have been an unusual confluence of issues.
<!--
Term "Winshock" being used for CVE-2014-6321 / MS14-066.
-->

<p>
It <i>is</i> known that
<a href="http://thesecurityfactory.be/command-injection-windows.html">Windows
scripts that are not properly quoted are vulnerable if an attacker
can create malicious filenames</a>.
Some seem to be calling this a &#8220;new&#8221; attack,
but I think that&#8217;s misleading; it&#8217;s just an old mistake.
The need to properly quote shell scripts, especially for filenames,
has been known for a long time, especially in the Unix-like world.
See my paper
<a href="filenames-in-shell.html">&#8220;Filenames and Pathnames in Shell: How to do it Correctly&#8221;</a>
for how to properly handle filenames in Unix-like shells, and
<a href="fixing-unix-linux-filenames.html">&#8220;Fixing Unix/Linux/POSIX Filenames: Control Characters (such as Newline), Leading Dashes, and Other Problems&#8221;</a>
for my proposal on how to reduce the likelihood of security
vulnerabilities stemming from filenames on Unix-like systems.


<p>
There are many online resources with more information, including
the
<a href="http://en.wikipedia.org/wiki/Shellshock_(software_bug)">Shellshock page on Wikipedia</a>
and
<a href="https://host-project.org/content/are-you-open-being-shell-shocked">HOST project page on Shellshock</a>.
You can also see the materials below, particularly
the <a href="#timeline">timeline</a> and
information about the specific <a href="#cves">CVEs</a>.



<h1 id="detect-or-prevent">How can we detect or prevent Shellshock-like vulnerabilities ahead-of-time?</h1>
<p>
I think it is critical to examine vulnerabilities to determine
how can we detect or prevent things like it from happening again,
ahead-of-time, and then doing those things.
We should look for things like
guidelines, rules of thumb, and detection techniques that would have
cost-effectively helped as early as possible.
For example, my paper
<a href="heartbleed.html">How to Prevent the next Heartbleed</a>
identifies a set of techniques that people can <i>apply</i> to detect
(and prevent) future problems like Heartbleed.
My papers on the
<a href="poodle-sslv3.html">POODLE attack against SSLv3</a>
and
<a href="apple-goto-fail.html">Apple goto fail vulnerability</a>
take similar approaches.
I am especially interested in approaches that software developers
or other technologists can apply <i>before</i> software gets
delivered to users.

<p>
This is not easy.
Crispin Cowan noted to me on 2014-10-03 that
&#8220;detecting command injection is *much*
harder than detecting memory corruption.&#8221;
Similarly,
<a href="http://www.openwall.com/lists/oss-security/2014/10/07/26">Michal Zalewski</a> noted that pondering
&#8220;why bugs happen and how we fix it&#8221; is a good thing to ponder,
but it is &#8220;certainly one where it&#8217;s difficult to come up with
fresh ideas :-(&#8221;.
I agree that it&#8217;s harder... but I still think it is a goal worth
pursuing.

<p>
This is not to mock the good work done by Brian Fox and Chet Ramey.
As noted in
<a href="http://www.wired.com/2014/09/shellshocked-bash/">
&#8220;The Internet Is Broken, and Shellshock Is Just the Start of Our Woes&#8221;
by Robert McMillan, <i>Wired</i>, 2014-09-29</a>:
<blockquote>
Brian Fox is still proud of the project he once drove across the country.
&#8220;It&#8217;s been 27 years of that software being out there
before a bug [causing a vulnerability] was found...
That&#8217;s a pretty impressive ratio of usage to bugs found.&#8221;
</blockquote>

<p>
Here are the approaches I have identified
(directly or with the help of others).
I first go over <a href="#general-points">a few general points</a>.
I then discuss some specific measures:
<a href="#document-interface">document the external interface precisely and review it for security</a>,
<a href="#namespaces">create namespaces where practicable</a>,
<a href="#separate-code-data">separate data and code</a>,
<a href="#minimize-functionality">minimize component functionality
and/or enable replacement</a>,
<a href="#sunset">sunset rarely-used functions</a>,
<a href="#avoid-unnecessary-use">avoid using components (like shells) unnecessarily</a>,
<a href="#explicit-import">require explicit import of data and code</a>,
and that there may be an approach involving
<a href="#taint-tracking">taint tracking</a>.
Finally, I point out that perfection is unlikely, so
system developers and operators must
<a href="#plan-vulnerabilities">plan for vulnerabilities (including least privilege and timely updates)</a>.


<h2 id="general-points">A few general points</h2>
<p>
Preventing software vulnerabilities requires countermeasures
throughout the software development process,
including requirements, design, implementation, and test.
This is true
regardless of what process you use (be it iterative, agile, or whatever).
You should use
general measures such as educating developers (so they know what to do),
identifying the program&#8217;s security requirements,
examining attack surfaces (to limit what
software is exposed to malicious input),
limiting privileges (including via sandboxes),
reducing complexity,
implementing the software in a way that avoids common mistakes,
using version control (e.g., using git),
performing peer review of changes (including analyzing it for security), and
evaluating software for vulnerabilities before release
(using both static and dynamic analysis approaches).
This is not a complete list, of course.
<a href="https://dwheeler.com/secure-programs">I have a freely-available
book focusing on the design and implementation of secure software</a>,
which has a lot of information on how to avoid common mistakes.
That said, I want to focus on specific approaches that would have probably
prevented or detected Shellshock
ahead-of-time, so that we can apply them.

<p>
There were multiple stages in Shellshock:
<ol>
<li>Realizing that a malicious attacker can add commands &#8220;after&#8221; a function definition, and that that is exploitable.  That was the original (and faulty) understanding of the problem.
<li>Realizing that merely having the shell parse data in normal environment variables <i>AT ALL</i> is exploitable, and needed to stop.
</ol>

<p>
One thing that made Shellshock hard to identify as a vulnerability
is that it is <i>expected</i>
that if an attacker can control arbitrary environment variables then
the system is already subverted.
There are many environment variables,
such as <tt>PATH</tt> and <tt>LD_PRELOAD</tt>, whose control would
enable attacker control.
Whenever you pass a security boundary (e.g., with setuid/setgid programs),
you must
<a href="https://dwheeler.com/secure-class/Secure-Programs-HOWTO/environment-variables.html">extract and erase environment variables, as I
point out in my book</a>.
On the other hand, there are specific environment variables
that are <i>expected</i> to be controlled by an attacker,
because they are used to pass data to a program that will check it.
For example, the CGI interface uses environment variables to pass data.
The Shellshock problem was that the bash parser itself was directly
parsing and responding to <i>all</i> environment variables, not just
the ones <i>documented</i> to affect bash (such as <tt>IFS</tt> and
the environment variables that affect the loader).

<p>
<a href="http://www.openwall.com/lists/oss-security/2014/10/07/26">As Michal Zalewski put it</a>,
&#8220;the bash bug was fairly unique and almost hilariously bad -
but also a bit intractable.
It dates back to the 80s,
[and] cropped up in a place where I certainly wouldn&#8217;t think to look...
Before this finding, it genuinely wouldn&#8217;t have occurred to most
people that auditing bash is a good use of their time and money, not
any more than it&#8217;s a good use of your time to audit /bin/uname...
This is actually probably a lot more significant for libraries that
don&#8217;t perform security tasks, but may be exposed in even more profound
ways (e.g., how much money goes to libpng, ffmpeg, imagemagick?)&#8221;.

<p>
Once people realized that the bash parser was generally exposed to attack,
many people quickly found vulnerabilities.
<a href="http://article.gmane.org/gmane.comp.security.fulldisclosure/1038">Michal Zalewski reported how he quickly found CVE-2014-6277 and CVE-2014-6278</a>
using the fuzzing tool
<a href="https://code.google.com/p/american-fuzzy-lop">american fuzzy lop</a>.
In short, once people realized that the bash parser was an attack surface,
standard techniques quickly found problems.

<p>
The biggest problem was realizing that arbitrary environment variables
were being processed by the bash shell, <i>and</i>
that this was a serious problem all by itself.
In my mind, we should focus on how to detect similar situations.

<h2 id="document-interface">Document the external interface precisely and review it for security</h2>

<p>
The fact that bash could export and import functions was well-documented.
However, <i>how</i> it exported and imported functions was <i>not</i>.
<p>
One possible countermeasure would have simply been to document
&#8220;all the ways that environment variables
are processed when the shell starts&#8221;.
Had it been noted that <i>any</i> environment variable beginning with
&#8220;()&nbsp;{&#8220; was specially processed,
I think it probably would have been identified much sooner.
Even the <i>process</i> of documenting it today might alert someone.

<p>
In any case, once the interface is more clearly documented,
then review the interface
to determine if that is appropriate from a security point-of-view.
The interface can be more easily reviewed once it is
documented more precisely.

<p>
The design interface can be documented
without specifying it as unchangeable interface.
Some people worry that by writing down the details of an interface,
they are guaranteeing that the interface cannot change or be improved.
But there is no reason to assume that.
For example, this information could be documented in a &#8220;design&#8221;
section describing how the current implementation works, perhaps
with an explicit statement that it might change in the future.
Another approach is to extend the <tt>ENVIRONMENT</tt> section of the manual.
It is common to list all environment variables affected by a program
in an <tt>ENVIRONMENT</tt> section of the manual.
The bash man page does not list the specific environment variables
that affect it in its <tt>ENVIRONMENT</tt> section, but it could
do so in a future version.

<p>
<a href="http://www.openwall.com/lists/oss-security/2014/10/08/5">Michal Zalewski states</a> that the shell function import
&#8220;feature was clearly added with no basic consideration for the
possibility of ever seeing untrusted data in the value of an
environmental variable.
This lack of a threat model seems to be the
core issue...
The detailed documentation part is perhaps easier to tackle.
The security properties of shells are generally under-documented and
counterintuitivie...
Decent security-centric docs,
authored or even merely just reviewed by the maintainers, would have
helped highlight the risk.&#8221;

<p>
<a href="https://www.schneier.com/blog/archives/2014/09/nasty_vulnerabi.html#c6679602">Dewey remarked on Bruce Schneier&#8217;s blog</a>,
when looking at the documentation,
&#8220;The string &#8216;()&nbsp;{&#8217; doesn&#8217;t appear once.
There are vague references to
&#8216;importing function definitions from the
shell environment&#8217; and the like,
but I can&#8217;t find any description of how it works.
There&#8217;s certainly no
huge warning like &#8216;bash will look at literally every environment variable
and import anything starting with
&#8216;()&nbsp;{&#8216; as a function&#8217;.
&#8216;Everyone knows&#8217;
that the environment is just a series of null-terminated key=value
strings which, in general, are not interpreted except as documented
in man pages for libc and each program that reads specific keys...
if it had been properly documented, someone would have probably figured
out earlier that this was a terrible idea... But we have to infer from
statements like &#8216;The export and declare -x commands allow parameters and
functions to be added to and deleted from the environment&#8217;,
and that&#8217;s
not nearly good enough for such a dangerous behavior.&#8221;


<h2 id="namespaces">Create namespaces where practicable</h2>

<p>
The eventual solution for Shellshock used by most implementations was to add
a prefix and suffix for specially-processed environment variables.
This created a special namespace for importing shell functions.
But you do not need to <i>know</i> of a vulnerability to use
solutions like this; simple heuristics could have gotten there.

<p>
In general, whenever using any shared resource (such as environment
variables or a filesystem), consider creating a separate namespace
for just your program&#8217;s use.
For example, when using environment variables, consider adding
a prefix or suffix in the name.
You should especially create a special namespace
when interpreting a large set of values instead of just a particular one
(such as &#8220;any function name&#8221; instead of
&#8220;PATH variable&#8221;).
<a href="https://www.schneier.com/blog/archives/2014/09/nasty_vulnerabi.html#c6679602">Dewey
remarked on Bruce Schneier&#8217;s blog</a>, &#8220;If the
vaguely-defined &#8216;importing function definitions&#8217; feature
had used &#8216;BASH_&#8217;-prefixed names, or names with any prefix,
these things would never have passed a whitelist.&#8221;
This has other advantages, e.g., it reduces the likelihood of
future conflicts with other programs or standards
which may otherwise use the same name.

<p>
The same approach applies to the filesystem.
A specially-designated file or directory, specifically set aside
for just your program, can eliminate the problems caused by shared resources.
If you plan to use a large number of files, for example,
put them all inside a directory that operates as the isolated namespace.
It is then easier to isolate that information from everything else.
This is already understood when dealing with temporary files and the
<tt>/tmp</tt> directory, but this is a broader principle that
can be reused elsewhere.

<p>
I should note that
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00322.html">St√©phane Chazelas recommended a slightly different namespace approach for function imports</a>, using a <i>single</i> environment variable
to pass the functions to be exported.
There are some advantages to this approach, e.g., there is less memory overhead
when there are many bash functions.
However, this would have required more analysis and work to implement;
when there was a rush to fix the problem permanently, approaches
that took longer were less welcome.
If the developers had used a namespace from the beginning, they would have
had time to consider the trade-offs before implementing something.
(It&#8217;s not clear to me that they would have done anything differently,
but it&#8217;s better to have the time to choose because there is no vulnerability.)


<h2 id="separate-code-data">Separate data and code</h2>

<p>
A related point is that data and code should be separated
to the extent possible, and not conflated.
<a href="http://www.openwall.com/lists/oss-security/2014/10/07/25">Some</a>
would say that this is basically the same as
<a href="#namespaces">separating namespaces</a>, but
for emphasis I will list this as a separate related point.
This is not always practical, but it is worth considering as a starting
point (and giving up only as necessary).

<p>
This point is somewhat subtle.
In a broader sense, all code is data.
Data and code are typically stored on the same storage media and
processed in the same memory.
Compilers (including Just-in-Time compilers) would not work if data and code
were <i>always</i> rigorously separated.
Yet maintaining a distinction can significantly improve security.

<p>
<a href="http://www.openwall.com/lists/oss-security/2014/10/09/8">I prefer
a functional kind of definition</a> for distinguishing data and code:
is there a way an attacker could send data that
would be interpreted as code?
If so, then you have not separated data and code.
Where possible, you should instead
separate data and code (so this cannot happen).
If you cannot reasonably separate data and code, then you need to prevent harm,
but it is <i>much</i> harder to prevent harm if attackers can send code.
Tools such as limited functionality, sandboxes, and whitelisted
safe patterns require a lot more analysis work to verify!
For security, the usual goal is to maximize the separation
so that attackers cannot provide code that the system will later execute.
The better the separation, the less risk later.

<p>
Note that using statically-compiled language does not eliminate
the need for this.
You can write a language interpreter in any Turing-complete language.
For example, you may be writing code in Haskell,
but it&#8217;s easy to create a Lisp interpreter in Haskell.
If an attacker can provide code that it
interprets, you have not separated data and code.

<p>
This is a point raised by
Crispin Cowan (on 2014-10-03 on a private mailing list);
<a href="http://www.tvworldwide.com/events/nsf/140717/">he has
previously spoken about the value of a &#8220;software Harvard Architecture&#8221;
where you systematically separate the data from the code</a>.
This logically moves away from the traditional Von Neumann architecture,
and thus eliminates the conflation of data and code.
<!--
Crispin Cowan, 2014-10-03 12:42PM, Robust Open Source [ROS] mailing list
-->
This point was also raised by
<a href="http://www.openwall.com/lists/oss-security/2014/10/07/25">Timothy D. Morgan (Tim) on oss-security</a>; some of the points below are from him.

<p>
Mixing data and code is at the root of many security problems.
As Tim notes,
&#8220;Any time you design a system to accept executable code as well as data
in the same format/context/whatever, you invite a huge number of
possible attacks.&#8221;
Examples include Microsoft Office files with embedded macros,
HTML with Javascript embedded in the same file, and
OGNL expressions in Apache Struts URL parameters.

<p>
Javascript was originally developed so that Javascript code
can be embedded in HTML data.
However, in many cases
it is difficult to write Javascript-based systems without vulnerabilities like
cross-site scripting (XSS), because the data and code are fundamentally mixed.
An emerging solution is
<a href="http://www.w3.org/TR/CSP/">Content Security Policy (CSP)</a>,
a W3C Candidate Recommendation, which
separate data and code.
CSP defines a new &#8220;Content-Security-Policy&#8221; HTTP header.
When this header is used, it
creates a whitelist of sources of trusted content for this webpage.
Compliant browsers will then only execute/render items from those sources.
This is supported in Chrome 16+, Safari 6+, and Firefox 4+
(unfortunately, IE 10 has only very limited support, but this still
means that many users are protected through it).
Twitter and Facebook have deployed CSP, and generally have had success.
Typically you must modify your website design to fully use CSP
(e.g., you must move the Javascript into separate files,
otherwise the receiving browser can&#8217;t distinguish
between whitelisted &amp; malicious Javascript).
Also, this only works when users use compliant browsers
(if Javascript had been <i>designed</i> from the beginning
to be in a separate file this would not have been a problem).
More information about CSP is available at
<a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/">HTML5rocks</a> and
<a href="https://blog.twitter.com/2011/improving-browser-security-csp">Twitter</a>.
This is a useful example of how to move an existing system
that mixes data and code into something that separates data and code.

<p>
A related issue is the dangerous ways that some Javascript programs,
especially early ones,
processed data in JavaScript Object Notation (JSON) format
by using <tt>eval</tt>.
JSON is a widely-used data format;
since it was derived from JavaScript and its syntax is (mostly)
a subset of Javascript,
it is often possible to parse JSON data by using
JavaScript&#8217;s <tt>eval</tt> function.
This is unsafe and can sometimes lead to a security vulnerability,
because
the <tt>eval</tt> function simply executes what it is passed,
yet JSON is normally only data.
Instead, developers should use a JSON parser designed to
read (or write) JSON.
Since 2010 web browsers have included native support for parsing JSON,
eliminating the temptation to use <tt>eval</tt> in this dangerous way.
Again, instead of mixing code with data, use techniques that separate them,
or at least process them in a way that does not lead to ordinary data
being treated as code.

<p>
In contrast,
Tim describes an example where people are having trouble due to the
mixture of data and code:
&#8220;In Apache Struts [at the moment],
OGNL is used are used to parse the entire POST body,
variable names and values.
However, OGNL expressions are executable code,
which breaks the whole assumption that POST variables are data.
So the Struts team is now playing whack-a-mole with blacklist blocking
of specific attack vectors...
In the case of Shellshock, the &#8216;mixing&#8217; of data and code came about
because environment variables, normally used to carry data, were
overloaded and used to carry code.
This is very similar to the Struts case.&#8221;

<p>
Crispin Cowan argues that instead of supporting eval (evaluation)
function of arbitrary data,
systems should require an explicit
&#8220;Clarke-Wilson ceremony&#8221; to convert untrusted data into
trusted code (if the source is trusted) or
harmless markup text (if the source is not trusted).
E.g., <a href="http://msdn.microsoft.com/en-us/library/ie/cc848922%28v=vs.85%29.aspx">ToStaticHTML</a> removes all dynamic HTML elements and attributes
from an HTML fragment.

<p>
<a href="http://www.openwall.com/lists/oss-security/2014/10/07/27">
Florian Weimer noted that calling <tt>eval</tt> (or its equivalent)
on untrusted input is a relatively common issue</a> - and is a bug.
Before evaluating anything, check to ensure there is no way that
untrusted input can get there (or if it can, ensure that it must always
be filtered and escaped in a safe manner).
I think this is another variant of the same point.
I should note that upstream bash, and most deployed versions,
<i>still</i> automatically import function definitions when included
in environment variable names with prefixes and suffixes.
This is currently considered acceptable by many people, because there
is no known mechanism for untrusted input to get there.
That said, this is not as safe as you might like;
<a href="http://seclists.org/oss-sec/2014/q3/771">I have previously argued</a>
that the <i>safest</i> course from a security point-of-view would be
to <i>both</i> apply the prefix/suffix namespace
(separating data and code), <i>and</i> to
require that function imports be specifically requested
(as implemented by
<a href="http://seclists.org/oss-sec/2014/q3/755">Christos Zoulas</a>).
I talk more below about
<a href="#explicit-import">requiring explicit import of data</a>.
This trade-off of potential risk (on the one hand), versus functionality and
backwards compatibility, is a constant issue.

<p>
This separation is especially important if you are using an
existing construct for storing data (such as environments).
As Timothy D. Morgan notes,
&#8220;When an existing construct in a system is widely expected to be used
for storing data, avoid overloading it for use of storing code.&#8221;
<!-- oss-security, Wed, 8 Oct 2014 16:53:32 -0700 -->

<p>
Separating data and code is something that can be accomplished
in many ways.
<a href="#namespaces">Separate namespaces</a> are one mechanism for
creating this separation, if you must use the same underllying system.
Separate files or URLs for data and code,
as done in the Content Security Policy (CSP),
is a related approach.
SQL injections are countered through prepared statements
(when used correctly), and prepared statements also separate data and code.
The point is to develop and use simple mechanisms that perform
this separation, and enforce them where practical.

<p>
Obviously there are places where this can only be partly achieved.
For example, the whole purpose of a shell (like bash)
is to accept data and execute it.
Still, shells should not execute arbitrary code provided by adversaries
without being asked to do so, and this was the problem with Shellshock.

<p>
In some cases full isolation between data and code
is not practical, and this can happen
in a surprising number of places.
For example, fonts and document formats like PDF include code.
In those situations you can try to isolate and separate to some extent.
In many cases it is possible to create a limited virtual machine that
cannot reach outside to other resources;
where this is not, treat it as executing malicious code and audit the
implementation carefully.
However, this is hard to do correctly, and many vulnerabilities have
been found in systems that take this approach.
Even if you do it correctly, it takes a lot of additional time
to ensure that it stays secure.
Thus, mix code with data only when you absolutely need to, and
be prepared for extra effort if you must do it.


<h2 id="explicit-import">Require explicit import of data and code</h2>

<p>
Shellshock turned an odd capability into a vulnerability because
bash automatically imported functions when environment variables
had values of a particular format.
Yet importing data and code does not need to be automatic.

<p>
In the case of Shellshock,
<a href="http://seclists.org/oss-sec/2014/q3/755">Christos Zoulas
created a patch that supported function import, but required
users to specifically request it</a>.
This eliminated practically all exploitations, because this
functionality was rarely used, and it could be enabled only in the few
cases it is needed.

<p>
There is precedence for this in the PHP language.
By default,
<a href="https://dwheeler.com/secure-class/Secure-Programs-HOWTO/php.html">in PHP versions 4.1.0 and lower, all environment variables and values sent to PHP over the web were automatically loaded into the same namespace (global variables) that normal variables are loaded into</a>.
This automatic setting of variables (essentially an import)
probably seemed convenient to the original PHP developers.
However, this meant that attackers could
set arbitrary variables to arbitrary values,
which keep their values unless explicitly reset by a PHP program.
In addition, PHP automatically creates variables
with a default value when they&#8217;re first requested,
so it&#8217;s common for PHP programs to not initialize variables.
This made it extremely difficult to write secure programs in PHP at the time.
PHP version 4.2.0 (which is now old) changed this, so
that by default external variables
(from the environment, the HTTP request, cookies or the web server)
are no longer registered in the global.
The preferred method of accessing these external variables
became using new Superglobal arrays, a mechanism for explicit imports
(instead of implicit imports).


<p>
There are other reasons to do this besides security, too.
Requiring a programmer to explicitly state what they are importing can
make it easier for later developers to see what the program
depends on, and thus can make it easier to maintain.

<p>
However, there are downsides as well.
Shells need to be easy to use;
requiring explicit importing creates some additional work,
especially if the import mechanism is poorly thought out.
In the case of bash, it also creates a backwards-incompatibility;
explicit imports are much easier to design into a language from the
beginning instead of changing to them later.

<h2 id="minimize-functionality">Minimize component functionality and/or enable replacement</h2>

<p>
When choosing security-relevant components,
choose components or their configurations to
minimize their functionality to the smallest extent needed.
Similarly, when implementing a component, consider if that functionality
is really needed, especially if might increase security risks.
This is not because smaller or less-functional components are
magically more secure; it is just that smaller and simpler components
are easier to thoroughly review, and so <i>if</i> there is review
the review is less likely to miss a security issue.
Finally, consider making it easy to replace (e.g., by following standards
so that you can easily replace a component with another implementation).

<p>
Debian and Ubuntu were much less vulnerable to Shellshock
compared to some other Linux-based systems like
Red Hat Enterprise Linux, CentOS, Fedora, or Oracle Linux.
That is because years ago
<a href="https://wiki.debian.org/Shell">Debian (starting with Squeeze)</a> and
<a href="https://wiki.ubuntu.com/DashAsBinSh">Ubuntu (starting with version 6.10)</a>
changed their default non-interactive shell
(aka <tt>/bin/sh</tt>) from <i>bash</i> to <i>dash</i>.
<a href="https://wiki.ubuntu.com/DashAsBinSh">This change
was primary made for efficiency; because bash is very full-featured, it is
rather large and slow to start up and operate by comparison with dash</a>.
Bash continues to be the default shell for <i>interactive</i> use on both
Debian and Ubuntu, because many interactive users prefer bash&#8217;s
richer feature set.
Also, a number of shell scripts require bash,
because those additional features are often very useful.

<p>
It is easy to show that dash is smaller than bash by measuring
source lines of code (SLOC).
SLOC is an imperfect but useful measure for estimating
development effort, size, and to some extent functionality.
I used my tool <a href="https://dwheeler.com/sloccount/">SLOCCount
version 2.26</a> to measure SLOC; it measures SLOC
as non-comment non-blank physical lines after automatically
detecting what language is used in each file.
Using SLOCCount, I find that dash version 0.5.8 has
14,208 physical SLOC (13,040 in C).
In contrast, bash version 4.3 (unpatched) has
115,715 physical SLOC (99,988 in C).
(I verified that the bash numbers do <i>not</i> include code
that is generated from flex or bison.)
In short, bash is over 8 times larger than dash by this measure.

<!--
Raw numbers from sloccount-2.26 when run on bash-4.3 (unpatched)
as downloaded from: http://ftp.gnu.org/gnu/bash/
I first ran "sloccount ." on the files as downloaded;
I then ran: ./configure && make maintainer-clean
to erase any potential generated code from bison or flex.
The numbers were the same, and I also verified that there were no
*.tab.* files, so clearly there were no generated files included in the count.
SLOC    Directory       SLOC-by-Language (Sorted)
48261   top_dir         ansic=43581,yacc=4680
45063   lib             ansic=44354,sh=322,yacc=316,asm=48,awk=23
13592   support         sh=5108,ansic=4257,perl=4227
3208    examples        ansic=2927,sh=281
3137    builtins        ansic=3112,sh=25
1485    include         ansic=1485
665     tests           sh=665
276     CWRU            ansic=272,sh=4
16      po              sed=16
12      doc             sh=12
0       cross-build     (none)
0       m4              (none)


Totals grouped by language (dominant language first):
ansic:        99988 (86.41%)
sh:            6417 (5.55%)
yacc:          4996 (4.32%)
perl:          4227 (3.65%)
asm:             48 (0.04%)
awk:             23 (0.02%)
sed:             16 (0.01%)




Total Physical Source Lines of Code (SLOC)                = 115,715
Development Effort Estimate, Person-Years (Person-Months) = 29.35 (352.18)
 (Basic COCOMO model, Person-Months = 2.4 * (KSLOC**1.05))
Schedule Estimate, Years (Months)                         = 1.93 (23.21)
 (Basic COCOMO model, Months = 2.5 * (person-months**0.38))
Estimated Average Number of Developers (Effort/Schedule)  = 15.17
Total Estimated Cost to Develop                           = $ 3,964,613
 (average salary = $56,286/year, overhead = 2.40).





Raw numbers from sloccount-2.26 when run on dash-0.5.8 (unpatched) from
http://gondor.apana.org.au/~herbert/dash/files/



SLOC    Directory       SLOC-by-Language (Sorted)
14208   dash-0.5.8      ansic=13040,sh=1168


Totals grouped by language (dominant language first):
ansic:        13040 (91.78%)
sh:            1168 (8.22%)




Total Physical Source Lines of Code (SLOC)                = 14,208
Development Effort Estimate, Person-Years (Person-Months) = 3.24 (38.94)
 (Basic COCOMO model, Person-Months = 2.4 * (KSLOC**1.05))
Schedule Estimate, Years (Months)                         = 0.84 (10.05)
 (Basic COCOMO model, Months = 2.5 * (person-months**0.38))
Estimated Average Number of Developers (Effort/Schedule)  = 3.87
Total Estimated Cost to Develop                           = $ 438,330
 (average salary = $56,286/year, overhead = 2.40).
SLOCCount, Copyright (C) 2001-2004 David A. Wheeler
SLOCCount is Open Source Software/Free Software, licensed under the GNU GPL.
SLOCCount comes with ABSOLUTELY NO WARRANTY, and you are welcome to
redistribute it under certain conditions as specified by the GNU GPL license;
see the documentation for details.
Please credit this data as "generated using David A. Wheeler's 'SLOCCount'."
-->


<p>
In theory this change should have been painless, because they
were switching from one POSIX-compatible shell to another.
In practice, it was not painless, but it was doable.
<a href="https://wiki.ubuntu.com/DashAsBinSh">Ubuntu&#8217;s DashAsBinSh</a>
lists the many ways that people accidentally depend on bash extensions.
A tool called <tt>checkbashisms</tt> was developed to find these
extensions, so that people could quickly find them and change them.
If people determined that the changes were too difficult, they could
change their scripts to make the dependency on bash explicit
(e.g., by making script headers <tt>#!/bin/bash</tt> and by modifying
Makefiles to say <tt>SHELL=/bin/bash</tt>).

<p>
This change was made much easier because there is a well-known standard
(POSIX) that is publicly available at no charge and is widely adhered to.
Modern POSIX systems are built from a large number of different components
that can be swapped out for other components, and this includes the shell.
(This design approach, using modular components with standardized
interfaces, is sometimes called a
&#8220;modular open systems approach&#8221;).
What is more, the work by Debian and Ubuntu
to ensure that shell programs were portable
should make it easier for other systems to consider doing the same.
I have anecdotal reports that some people switched their individual systems
<tt>/bin/sh</tt> from bash to another shell (like dash)
temporarily; this switch was only possible
because there were ready alternatives.

<p>
Their experience does illustrate some of the problems of this approach.
In some situations it is rather difficult or time-consuming to develop
software without the additional functionality
(for example, bash adds support for arrays,
and some programs are hard to create in shell without them).
Still, this is an approach worth considering.
Tools can be developed to help with the transition, or the
more-limited component could be slightly extended
just enough to ease the transition.
The Debian/Ubuntu experience also shows that you do <i>not</i> have to
<i>always</i> give up functionality; instead, you can choose a
component with more restricted functionality in most cases, and
use a more full-featured component only when it is needed.

<p>
And of course, there are some controversies based on whether or
not dash is really countering attacks as well as it could be.
<a href="http://blog.cmpxchg8b.com/2013/08/security-debianisms.html">As
Tavis Ormandy noted in 2013</a>,
both bash and ksh include an interesting hardening technique that he says
&#8220;is surprisingly effective at mitigating some
common vulnerability classes and misconfigurations.&#8221;
He notes that bash will
&#8220;drop privileges very early if uid != euid&#8221; (i.e., is called
indirectly through a setuid program) in various cases
(<a href="https://bugs.launchpad.net/ubuntu/+source/dash/+bug/1215660">e.g.,
when called as bash without privilege mode</a>).
The pdksh shell version 5.0.5 or later also includes this technique.
However, this hardening technique
<a href="https://bugs.launchpad.net/ubuntu/+source/dash/+bug/1215660">had
not been incorporated into dash</a> when shellshock was revealed
(if was incorporated later in 2015).
My point is that switching is not always as straightforward an answer as
you might think.

<p>
It&#8217;s worth noting that
<a href="http://lists.research.att.com/pipermail/ast-users/2014q3/004637.html">ksh was not vulnerable to Shellshock</a> because they
intentionally decided to <i>not</i> implement function imports.

<h2 id="avoid-unnecessary-use">Avoid using components (like shells) unnecessarily</h2>

<p>
Many programs need to invoke other programs.
An easy way to do this is by using a shell, so
many languages have built-in functionality that make it easy to invoke a shell.
C and C++, for example, have <tt>system()</tt> and <tt>popen()</tt>.
Other languages that provide easy-to-use methods to invoke the shell
include Java, Perl, and Python.
However, in many cases there is no real reason to ask the shell to
execute a program if all you are doing is executing another program.
Instead, simply execute the program directly.
This is more efficient, and reduces any risk of shell vulnerabilities
(since the shell is not involved).
<p>
In short, go ahead and (carefully) use the shell or any other component
if you need to in a program that might be attacked.
However, only use a component if it really
provides an easier or better way to do a job!
This would not have eliminated Shellshock, but it would have
reduced its effects.


<h2 id="sunset">Sunset rarely-used functions</h2>

<p>
A more controversial approach would be to
aggressively sunset (remove) features that do not catch on,
a possible approach mentioned by
<a href="http://www.openwall.com/lists/oss-security/2014/10/08/5">Michal Zalewski</a>.
Bash has had function imports for 25 years, but many
users were unaware of it.
I personally use bash daily since around 1995
and didn&#8217;t know about this capability.
Many others (including
<a href="http://seclists.org/oss-sec/2014/q3/663">Michal Zalewski</a>)
said the same thing.
Both Shellshock and Heartbleed were fundamentally exploits
involving rarely-used functionality;
removing rarely-used functionality could eliminate them as attack vectors.

<p>
That said, this is an idea that is hard to apply in practice.
Bash is widely used in part <i>because</i> its developers try to
<i>not</i> harm backwards compatibility.
(Sometimes backwards compatibility <i>is</i> broken, but my point
is that the developers usually try to remain backwards-compatible.
<a href="http://tiswww.case.edu/php/chet/bash/COMPAT">Here is a list
of known backwards incompatibilities</a>.)
<a href="https://lwn.net/Articles/614218/">Weimer found a number of uses of
bash function export/import, especially in test harnesses,
in a search through Debian&#8217;s code repository</a>.
So while I think this is an idea worth pursuing in general, it
is less likely that it would have countered Shellshock.

<h2 id="taint-tracking">Taint tracking</h2>
<p>
I and other people suspect that taint tracking could be used
in some way to detect these kinds of problems.
<a href="https://dwheeler.com/trusting-trust/#micro-tainting">Micro-tainting,
for example, could track at a finer grain where data came from</a>,
and an automated detection system could perhaps be created this way.
A variant of this approach is to use some sort of advanced type system
(which in some ways is a kind of taint tracking).
At this point this is a vague idea, not a specific process;
suggestions welcome.

<span id="update"></span>
<h2 id="plan-vulnerabilities">Plan for vulnerabilities (including least privilege and timely updates)</h2>

<p>
Security vulnerabilities should be detected and
eliminated <i>before</i> they are deployed where they can,
but clearly that does not always happen.
Unfortunately, many systems are not ready for the inevitable vulnerability
disclosure, be it Shellshock or anything else.
You should plan for the occasional vulnerability discovery,
including using least privilege and timely updates,
so I will now discuss those.

<p>
First,
systems should be designed and implemented so that they have least privilege.
In short, break components down and only give them the access they need
(through file privileges, SQL grants, sandboxes, and so on).
Consider designing with
&#8220;mutually suspicious components&#8221; - then, if one component is
broken into, that does not mean the whole system is owned.
One widely-available mechanism for constraining damage on Linux-based
systems is SELinux.
As
<a href="https://danwalsh.livejournal.com/71122.html">Dan Walsh noted</a>,
&#8220;SELinux does not block the exploit but it would prevent
escalation of confined domains...
SELinux would probably have protected a lot/most of
your valuable data on your machine.
It would buy you time for you to patch your system.&#8221;
<a href="http://cybermatters.info/2014/10/09/shellshock-selinux/">Colin Powers
has some pictures showing how SELinux constrains damage</a>.

<p>
Also, you and your systems need to be <i>prepared</i> to have timely updates.
The big concern now with Shellshock are the systems
that did <i>not</i> quickly apply the patch or other countermeasures
(such as traffic filtering).
Full patches for bash were available quickly, but that does not
matter if system developers and administrators do not deploy it.
This is especially an issue for embedded systems including cheap routers
and the cell phone components used by mobile phones, because they
are often not prepared for updates.

<p>
People need to be either prepared to update their systems quickly,
<i>or</i> have it done automatically for them.
Increasingly people are deploying embedded systems that
are not prepared to be rapidly or automatically updated;
indeed, they often cannot be practically updated at all.
This lack of preparedness puts us all at risk.
Organizations should be required to either provide timely updates,
or provide users with the means necessary so that they can update
their systems (e.g., the ability to update the software), at least
for a reasonable length of time (say, a decade).
In many cases, updates should be automatic unless the user specifically
says otherwise; there are simply too many devices to keep track of otherwise.
Automated updates are a risk, but automated regression test suites,
data standards, digitally-signed updates,
and rollback functionality can greatly reduce that risk.

<p>
<a href="https://www.youtube.com/watch?v=nT-TGvYOBpI">Dan Geer,
in his Black Hat USA 2014 keynote
talk &#8220;Cybersecurity as Realpolitik&#8221;</a>,
makes a related point.
He proposed that &#8220;embedded systems cannot be
immortal if they have no remote management interface&#8221;.
He noted that,
&#8220;what is sold at Best Buy or the like is remarkably
cheap and remarkably old...
[since] the average [codebase age] is 4-5 years, then ...
the CVE catalog lists numerous methods of attacking
those operating systems and device drivers remotely.&#8221;


<p>
These are not <i>preventative</i> measures, and preventative measures
are in many ways the best.
That said, we need to be prepared
when the preventative measures inevitably fail.

<!--

===
On 2014-10-03, on [ROS]
Jonathan S. Shapiro  - shap, at, eros-os / org

While your point about syntax vs. semantics is well taken, I wonder if we need to go that far. If we don't want to process *any* command from user input, then we only need to recognize that a command is present, rather than needing to examine what it means. That's still a syntax problem. If we want to process "safe" commands but not "unsafe" commands, then I agree it becomes a (very hard) semantics problem.

Starting from the position of "no commands taken from the user" seems like the conservatively correct default. Would a simpler approach like dynamic tainting have helped here? Something along the lines of "the value in that variable was the result of READ and is therefore tainted as *userinput*. Values tainted by *userinput* should not be processed by EVAL. The scheme would have to be extended over some operators like concatenation so that the taint gets propagated properly. The intent would be for the programmer to have to turn off the taint explicitly somewhere at the end of an input validation procedure of some sort.

I've seen some good work on typing things like SQL input in some strongly typed languages. The general idea seems to be that you first process user input fields into an AST form before merging the field into a larger SQL statement. If the user-supplied AST is malformed, or isn't of the AST type required to fit into the larger query, you don't take it. Similar things have been done for a couple of other kinds of "internal processing sub-language" sorts of situations.

From a programmer perspective, the thing that makes the "typed SQL AST" idea work is that you eliminate the string-based API to the SQL engine altogether, accepting a query AST instead. This forces the developer to produce the query AST, which makes them gnash their teeth a bit, which in turn makes them ask "why do I have to do this", which directs them to documentation that educates them about the problem. Couple that with a very modest amount of HTML form processing toolkit support and all of a sudden you've got them implementing input validation.

I wonder if something like that could be done for the shell in some degree?
===

-->

<h2 id="broad">Fix vulnerabilities broadly, not just the proof-of-concept</h2>

<p>
A common problem is that when receiving a vulnerability report, many
developers only fix the code enough to counter the proof-of-concept
instead of broadly fixing the underlying problem.
That certainly happened with Shellshock.
This makes things worse, because then attackers around the world are notified
of exactly where the software is weakest.
<p>
Developers, when presented with a vulnerability, should determine how to
broadly harden the software against all similar attacks, not just fix
the specific proof of concept.


<h1 id="timeline">Timeline</h1>

<p>
Below is a timeline of Shellshock, including citations to justify it.
My sincere thanks to those who helped, including
St√©phane Chazelas
(e.g., for
<a href="http://seclists.org/oss-sec/2014/q4/93">vulnerability insertion dates</a> and
<a href="http://seclists.org/oss-sec/2014/q4/102">report times</a>)
and Eric Blake
(e.g., for <a href="http://seclists.org/oss-sec/2014/q4/96">bash patch dates</a>).
Remember that people do not necessarily represent the organizations
they work for.

<p>
In this timeline I use <i>primary</i> sources where possible,
since they are the most reliable sources of information.
In most cases the primary sources are either
verifiable logs with date-time stamps (in ChangeLog files or git logs)
or public postings by the actual participants (on a mailing list or Twitter).
For example, it was widely reported that the Shellshock vulnerability
was introduced in 1992, but this is
<a href="http://seclists.org/oss-sec/2014/q4/93"><i>incorrect</i></a>.
As explained below, primary sources prove
that the Shellshock vulnerability was introduced into bash on
1989-08-05 08:32:05 -0700 (timezone estimated) and later released
as part of bash version 1.03.

<p>
Timezone information is often vital because
people rapidly responded from around the world.
The timezone &#8220;Z&#8221; represents
<a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">Coordinated Universal Time (UTC)</a>.
You can convert all other times to UTC by subtracting the timezone offset
(recall that subtracting a negative is the same as adding a positive).
Twitter shows date and time, but does not normally show the timezone
for a tweet.
However, using
&#8220;view source&#8221; reveals <tt>data-time</tt> values;
<a href="https://webapps.stackexchange.com/questions/17533/how-to-find-the-exact-time-a-tweet-was-tweeted">StackExchange confirms that these are
Unix time values</a>,
so I used
<a href="http://www.unixtimestamp.com/index.php">Unixtimestamp</a> to
convert these values to UTC and then determined their timezone.
Github does not visibly show exact times, but <tt>git clone</tt>
downloads the metadata including exact times.
The seconds value in the old times may be slightly off, but modern systems
typically have excellent time accuracy due to capabilities such as the
network time protocol (NTP).
<p>

<table border="1">
<tr><td>1989-08-05 08:32:05 -0700 (timezone estimated)<td>
Shellshock vulnerability accidentally introduced into the development
version of bash by
then-lead bash developer Brian Fox, as part of an addition to
support function export and import.
The date of insertion is confirmed by a
<a href="http://www.oldlinux.org/Linux.old/bin/old/bash-1.05/ChangeLog">bash ChangeLog</a>.
The &#8220;<a href="http://seclists.org/oss-sec/2014/q4/102">code is very simple, it just replaces the = with a space in the
environment entry and interprets it</a>&#8221;.
<a href="https://groups.google.com/forum/#!msg/comp.unix.questions/LwsdchovzFY/qokUr2mfCboJ">Chet Ramey notes on 1989-09-02</a> that an advantage of bash
over ksh is that bash supports function export.
A later
<a href="https://groups.google.com/forum/#!msg/gnu.bash.bug/72jXoIWYsfE/jJqC-fjSh0wJ">post by Brian Fox on 1989-09-08 04:54:05 EDT</a>
also notes that bash 1.03 can export functions, and explains how:
&#8220;Upon reading in the environment, if a string of the form &#8220;name=() {&#8220; is
found, then that is a function definition.&#8221;
This is the mechanism that turns out to be vulnerable.
More information is posted at
<a href="https://unix.stackexchange.com/questions/157381/when-was-the-shellshock-cve-2014-6271-7169-bug-introduced-and-what-is-the-pat/157495#157495">StackExchange responses to &#8220;When was the Shellshock (CVE-2014-6271/7169) bug introduced, and what is the patch that fully fixes it?&#8221;</a>
The timezone is estimated from the fact that
<a href="http://www.wired.com/2014/09/shellshocked-bash/">Brian Fox
moved to Santa Barbara in 1987</a>
and <a href="http://www.timeanddate.com/time/dst/1989.html">daylight
savings time would have been in effect</a>
(thanks to David Woodhouse for reminding me of the latter correction).
<!-- In 1989 daylight savings time was in effect in California from
Sunday, April 2, through Sunday, October 29.
David Woodhouse credit: dwmw2 at infradead.org
-->
Note that this date is relatively soon after
<a href="https://www.scribd.com/doc/40556434/2010-10-31-Chet-Ramey-Early-Bash-Dates">the first beta release of bash (1989-06-07),
and bash development had only begun in late 1987</a>.
<!--
Brian released bash-1.12 in February 1992, but he was laid of by FSF
and effectively stopped working on bash by mid-1992.
Source for this and previous statements:
"2010-10-31 Chet Ramey Early Bash Dates" -->
My thanks to
<a href="http://seclists.org/oss-sec/2014/q4/102">Eric Kobrin (Akamai) who
found this information and also to
St√©phane Chazelas who posted the information to oss-security on
2014-10-04 09:19:07 +0100</a>
(<a href="http://www.openwall.com/lists/oss-security/2014/10/04/4">alternate link</a>).
This date (and supporting information) was difficult to track down, so
<a href="http://seclists.org/oss-sec/2014/q4/93">many early reports gave the wrong date for vulnerability insertion (1992 is <i>incorrect</i>)</a>.

<!--
This was difficult to track back; for a long time the earliest
people could date it was circa 1989.
One source for this date is
<a href="http://www.theregister.co.uk/2014/09/24/bash_shell_vuln/">&#8220;Patch Bash NOW: &#8216;Shellshock&#8217; bug blasts OS X, Linux systems wide open&#8221; by John Leyden, <i>The Register</i>, 24 Sep 2014</a>.

Another effort to find history was here:
http://www.openwall.com/lists/oss-security/2014/10/04/2
-->


<tr><td>1989-09-01 18:52:08 -0700 (timezone estimated)<td>
Brian Fox releases version 1.03 of bash with the vulnerability included
in it.
The sources for this information are the same as the previous entry;
<a href="http://seclists.org/oss-sec/2014/q4/93">here is a brief
discussion about this date</a>.


<tr><td>2014-09-12 16:10:35 +0100<td>
St√©phane Chazelas reports the vulnerability in bash to
Chet Ramey (the lead bash developer) and the security
contacts of Debian, Red Hat, Ubuntu and Mandriva (SUSE was added later).
This included
&#8220;details of the bug and the SSH and HTTP (Apache
header) vectors and mitigation and a bit fat warning that it was
very serious and not to be disclosed&#8221;.
This newly-found vulnerability was assigned the identifier CVE-2014-6271.
St√©phane Chazelas found this vulnerability
in the morning of the same day (2014-09-12 in the UK), after
<a href="http://www.openwall.com/lists/oss-security/2014/10/08/17">reflecting on an earlier vulnerability he had
reported in libc (CVE-2014-0475)</a>
that had involved environment variables
and was aggrevated by design choices in bash.
<!--
From oss-security posting:
Wed, 8 Oct 2014 16:11:22 +0100
	From: 	"stephane.chazelas" <stephane.chazelas@gmail.com> [Add to Contacts] 	  [Whitelist sender] [Blacklist sender] [Block domain]
	To: 	"David A. Wheeler" <dwheeler@dwheeler.com>
	CC: 	oss-security <oss-security@lists.openwall.com>
	Subject: 	Re: St√©phane Chazelas: How *DID* you find Shellshock?   	 Tags
	2014-10-08 10:26:21 -0400, David A. Wheeler:
This is a question for St√©phane Chazelas, but I'm "cc"ing
oss-security because I think many of us want to know the
answer.

St√©phane: How *DID* you find Shellshock, in as much detail as you can recall?

I'm told you found the bug after "reflecting on an earlier
bug" you found in bash "a few months earlier."
(http://www.smh.com.au/it-pro/security-it/stephane-chazelas-the-man-who-found-the-webs-most-dangerous-internet-security-bug-20140927-10mixr.html)

What I'm hoping is that we can learn some lessons and re-apply
them elsewhere.
[...]

That's something I've been asked often and all the journalists
have transformed what I said.

In any case, I didn't find the bug by observing exploits, I have
no reason to beleive it's been exploited before being disclosed
(though of course I can't rule it out). I did not find it by
looking at bash's code either.

some copy-pasting of what I've said to others:

In July, I had found a vulnerability in the GNU libc (not bash)
related to environment variables (CVE-2014-0475). It could be
network exploitable with one particular vector: the bypass of
OpenSSH's ForceCommand (used for instance in git servers or
poor-man's VPNs). And it was agravated by a poor design choice
of bash [(actually two: the parsing of .bashrc over ssh and the
locale dependant parsing (that latter one not specific to
bash))] which again could cause arbitrary command execution if
enough conditions were met (a very narrow attack surface
compared to Shellshock).

Again, that was not following any observation of an exploit
attempt, just a reflection on a mechanism I knew about.

I put that attack vector in context with that little known
feature of bash, the exporting/importing of functions for which
I already knew part of the mechanism. Started to think of the
possible way it was implemented, thought that it could very well
be the very simplest way, in which case that was a big security
hole.

More details at

http://thread.gmane.org/gmane.comp.shells.bash.bugs/22367
Which I've just posted.

and:

http://thread.gmane.org/gmane.comp.shells.bash.bugs/22096
-->
As is routinely done, release of details was briefly embargoed.
Private discussions were held about the best way to solve the problem,
and patches were developed by the bash developer Chet Ramey
for a planned coordinated announcement.
There were conflicting reports about the date;
<a href="http://seclists.org/oss-sec/2014/q4/92">the dates and other
information reported by St√©phane Chazelas himself are used here</a>
(because he is a primary source).
The article <a href="http://www.smh.com.au/it-pro/security-it/stephane-chazelas-the-man-who-found-the-webs-most-dangerous-internet-security-bug-20140927-10mixr.html">&#8220;St√©phane Chazelas: the man who found the web&#8217;s &#8216;most dangerous&#8217; internet security bug&#8221; by Ben Grubb, <i>The Sydney Morning Herald</i>, September 27, 2014</a>, provides some interesting
early information,
but it includes an incorrect date of 2014-09-09 as the report date, and it also
incorrectly claims that the previous vulnerability Chazelas reported
was in bash (it was actually in GNU libc, and merely aggrevated by
bash functionality).
The article
<a href="http://www.nytimes.com/2014/09/26/technology/security-experts-expect-shellshock-software-bug-to-be-significant.html?_r=0">
&#8220;Security Experts Expect &#8216;Shellshock&#8217; Software Bug in Bash to Be Significant&#8221;
by Nicole Perlrothsept,
<i>The New York Times</i>, 2014-09-25</a>
gives the correct Shellshock report date, 2014-09-12.


<tr><td>2014-09-14 14:29:48 +0100<td>
<a href="http://seclists.org/oss-sec/2014/q4/92">St√©phane Chazelas proposes
that this vulnerability be named &#8220;bashdoor&#8221;</a>.
However, this proposed name is
<a href="http://seclists.org/oss-sec/2014/q3/650">not mentioned in early
announcements of the vulnerability</a>, and
in the end this name does not catch on.

<tr><td>2014-09-16 22:00:02 -0400<td>
Chet Ramey has all final (before disclosure) fixes for the
current and all past versions of bash back to 3.0 by 2014-09-16.
Source: <a href="http://seclists.org/oss-sec/2014/q4/92">St√©phane Chazelas</a>.

<tr><td>2014-09-22 07:16:35 +0200<td>
Florian Weimer notifies the private
PGP-re-encrypting distros list
with subject &#8220;CVE-2014-6271 in bash&#8221;.
It had no detail, but instead stated,
&#8220;At 2014-09-24 14:00 UTC, we are going to disclose a significant
security vulnerability in bash.
Please contact the Debian security team...
to receive details and upstream patches.  Today, this alias will be
staffed at least until 21:00 UTC (13:00 PDT).&#8221;
<a href="http://www.openwall.com/lists/oss-security/2014/10/05/13">This was later confirmed by Solar Designer</a>.

<tr><td>2014-09-24 16:05:51 +0200<td>
Vulnerability announcement released to the public, as planned,
as CVE-2014-6271, a few minutes
after the established embargo time of 2014-09-24 14:00 UTC.
This announcement was reported on the
<a href="http://oss-security.openwall.org/wiki/mailing-lists/oss-security">oss-security mailing list</a>
by Florian Weimer (<a href="http://developerblog.redhat.com/author/florianweimer/">Red Hat Product Security Team</a>)
in a
<a href="http://seclists.org/oss-sec/2014/q3/649">short</a> and
<a href="http://seclists.org/oss-sec/2014/q3/650">long</a> announcement.
At around the same time
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00081.html">Chet Ramey releases official patch 25 for bash 4.3 (the current version),
aka &#8220;bash43-025&#8221;,
along with related patches for past versions of bash</a>,
that is intended to fix the vulnerability.
Distributions who had participated in the coordinated disclosure
released their patches as well.
This public report reflected the original understanding of the problem:
&#8220;environment variables are processed: trailing code in function
definitions was executed, independent of the variable name.
In many common configurations, this vulnerability is exploitable over
the network.&#8221;
Up to this time this has been a typical coordinated disclosure process;
it will now change into a full disclosure process.

<tr><td>2014-09-24 18:36:16 +0200<td>
<a href="http://seclists.org/oss-sec/2014/q3/659">Florian Weimer noted
on the oss-security list</a>, &#8220;It was pointed out to me off-list
that a patched bash will still import functions from the environment,
including from variable names which override shell commands. This is
not an immediate vulnerability because it requires setting environment
variables under *specific* names... [but] My main concern with the
current patch is that still exposes the bash parser and function
definition printer to attacks from the network. Bugs in those fairly
large components could cause another critical issue.&#8221;
<!--
Around this time
security researchers begin suspect that that the fix is incomplete.
Even after the patch, attackers can cause bash functions to be defined
and thus force the bash parser to process untrusted data.
-->

<tr><td>2014-09-24 16:42:21 +0000<td>
<a href="https://mobile.twitter.com/addelindh/status/514817121101283328">Andreas Lindh proposes the name &#8220;Shell Schock&#8221; via a tweet</a>.
<a href="http://blog.erratasec.com/2014/09/bash-bug-as-big-as-heartbleed.html">Robert Graham noted the name later</a> (with more conventional spelling),
and <a href="https://twitter.com/addelindh/status/514840916692324352">Andreas Lindh created a proposed logo in response</a>.
This is confirmed by a tweet where
<a href="https://twitter.com/ErrataRob/status/514919756026351616">Rob Graham credits Andreas Lindh for coining the name Shellshock</a>.
(My thanks to Larry W. Cashdollar who pointed me to this information.)

<tr><td>2014-09-24 11:54:18 -0700<td>
<a href="http://seclists.org/oss-sec/2014/q3/663">Michal Zalewski replied to Florian Weimer on oss-security</a>,
&#8220;Yup, that surprised me when testing the patch, too -
I can still get a
function called HTTP_COOKIE, for example. I worry about potential side
effects of parsing even in absence of parser bugs...
Bash may be saved by simplicity, but [I am] not sure how robust
that assumption is...
I&#8217;ve written more code in bash than I should have and never used
function exports, or even realized that they exist. I wonder if they
can be made optional (e.g., gated by a flag on the subprocess) without
breakage...
Another option may be to export them through specially prefixed
variables, which should be transparent but minimize the risk of
interfering with web servers and such.&#8221;
(<a href="http://lcamtuf.blogspot.de/2014/09/quick-notes-about-bash-bug-its-impact.html">Zalewski created a blog post on 2014-09-25 with some additional detail, e.g., about his HTTP_COOKIE comment</a>.)

<tr><td>2014-09-24 17:17:00 -0400<td>
<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1141597#c23">Tavis Ormandy (Google) posts on the Red Hat Bugzilla bug tracker for CVE-2014-6271 that
&#8220;the fix seems incomplete&#8221;</a> - and shows a bash parser bug
that works even after the initial bash patch is applied.
A few minutes later, on
<a href="https://twitter.com/taviso/status/514887394294652929">2014-09-24 21:21:35Z, Tavis Ormandy tweeted the new Shellshock attack</a>.
If the variable name in an assignment is surrounded by parentheses the
parser fails and begins executing the commands that follow.
This is assigned CVE-2014-7169, though there is disagreement on its severity.
<a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-7169">National Vulnerability Database</a> gives it as CVSS Severity score of 10 out of 10.
<a href="http://article.gmane.org/gmane.comp.security.fulldisclosure/1038">Michal Zalewski later stated</a>
that this has &#8220;limited exploitability&#8221; by itself.
However, the real point is that Tavis&#8217;
attack provides direct evidence that attackers should absolutely
<i>not</i> be able to send data directly to the bash parser.
<!--
Note: The externally-visible time reported by Twitter is 2014-09-24 14:21,
but viewing the HTML source shows data-time=&#8220;1411593695&#8221;.
-->

<tr><td>2014-09-24 15:38:31 -0600<td>
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00094.html">Eric Blake posts on bug-bash</a>,
and suggests that in response to the flaw reported by Tavis Ormandy,
&#8220;I think that exporting functions via names that CANNOT be
valid normal variables, rather than excluding a subset of values to
normal variables that cannot be exported, would be the better course of
action...
I&#8217;d feel much more comfortable with exporting f()=... as the
backdoor for passing the function definition, _particularly_ since the
shell already allows functions and variables to co-exist...&#8221;.
Note that this suggests adding a suffix.
<!--
Noted in: http://seclists.org/oss-sec/2014/q4/98
(and I agree).
-->

<tr><td>2014-09-25 14:37:26 +0200<td>
<a href="http://www.openwall.com/lists/oss-security/2014/09/25/13">Florian Weimer (Red Hat) posts on oss-security</a>
a patch for bash that generally counters the attack.
In this patch, environment variables are <i>only</i> examined for
shell functions if the variable names begin with prefix
&#8220;<tt>BASH_FUNC_</tt>&#8221; and suffix &#8220;<tt>()</tt>&#8221;.
Adding prefixes had been previously suggested by Michal Zalewski;
suffixes had been previously suggested by Eric Blake.
Florian first posted this directly to Chet Ramey (bash maintainer),
and a few minutes later posted it to the oss-security mailing list
(the public posting time is used here).

<tr><td>2014-09-25 09:52:18 -0400<td>
<a href="https://github.com/akamai/bash/commit/7caac6ee41f645fc21b6e5eddc820151f6e6c43c">Eric Kobrin (Akamai) posts on github a patch</a>
that lets builders disable or enable function export/import at compile time,
so that the dangerous functionality can be easily disabled.
This commit (7caac6ee41f645fc...) makes
function forwarding conditional on the compile-time switch
<tt>FUNCTION_EXPORT</tt>.
Soon afterwards (11:53:41&nbsp;-0400) Eric&#8217;s colleague
<a href="http://www.openwall.com/lists/oss-security/2014/09/25/22">Larry W. Cashdollar notifies oss-security about the patch</a>.
This patch is noted in an
<a href="https://blogs.akamai.com/2014/09/environment-bashing.html">update post by Andy Ellis (Akamai) at 2014-09-25 11:30</a>
as an emergency patch that Akamai is using to counter the attack.
This approach is (in the end) not directly picked up by any distribution,
but it shows the alternatives being considered, developed, and deployed
at the time.

<tr><td>2014-09-25 17:41 -0500<td>
<a href="https://www.schneier.com/blog/archives/2014/09/nasty_vulnerabi.html#c6679473">Antti Louko posts on Bruce Schneier&#8217;s blog
how bash could be binary-patched to prevent the problem</a>.
He suggests opening bash (e.g., with Emacs), search for
&#8220;()&nbsp;{&#8220;, and replace &#8220;(&#8220; with a null character to disable
function import from the environment.
He later posts a long Python program to do this.
(<a href="http://seclists.org/oss-sec/2014/q4/120">Actual name and
citation provided by Solar Designer</a>).
<!--
Bruce Schneier's blog did not publicly post timezone information.
I asked him what timezone he used on his blog,
and on Tue, 07 Oct 2014 13:46:00 -0500, Bruce Schneier replied:
Central. Currently CDT.
-->

<tr><td>2014-09-26 05:15Z<td>
Red Hat announces release to its customers of an updated bash package based on
<a href="http://www.openwall.com/lists/oss-security/2014/09/25/13">Florian Weimer&#8217;s</a> approach (covering a variety of systems including
Red Hat Enterprise Linux 4, 5, 6, and 7).
They state that, &#8220;Red Hat has become aware that the patch for
CVE-2014-6271 is incomplete. An attacker can provide specially-crafted
environment variables containing arbitrary commands that will be executed
on vulnerable systems under certain conditions. The new issue has been
assigned CVE-2014-7169.&#8221;
This updated release
completely eliminates the Shellshock problem for their customers.
Note that at this point the upstream bash developers have not yet
fully fixed the problem.
The source for this date/time is
<a href="https://access.redhat.com/articles/1200223">Bash Code Injection Vulnerability via Specially Crafted Environment Variables (CVE-2014-6271, CVE-2014-7169)</a>.

<br><br>
In general, distributions rapidly deploy
a broad defense to eliminate the problem, without waiting for the
lead bash developer to determine how to fix it upstream.
For Red Hat customers the approach was designed, implemented, tested,
and deployed in about 32 hours, which is pretty speedy;
many other organizations did similarly.
Red Hat, CentOS, Fedora, Debian, and Ubuntu adopt Florian Weimer&#8217;s
prefix/suffix approach.
Apple will later adopt a variation of it
(with a slightly different prefix and suffix).
In contrast, NetBSD and FreeBSD will disable automatic imports
(imports must be specifically requested) per a
<a href="http://seclists.org/oss-sec/2014/q3/755">patch proposed by
Christos Zoulas</a>, which also eliminates the vulnerability.

<tr><td>2014-09-26 13:47:51 +0100<td>
<a href="http://seclists.org/oss-sec/2014/q3/748">John Haxby (Oracle)
posts</a>: &#8220;It&#8217;s not so much the known attacks -- redefining
ls, unset, command, typeset, declare, etc -- it&#8217;s the future parser
bugs that we don&#8217;t yet know about.  <i>A friend of mine said this
could be a vulnerability gift that keeps on giving.</i> CVE-2014-7169 was
discovered very quickly after CVE-2014-6271.  Do you think that&#8217;s
the end of it?&#8221;

<tr><td>2014-09-26 10:13:22 -0400<td>
<a href="http://seclists.org/oss-sec/2014/q3/755">Christos Zoulas posts a patch on the oss-security mailing list
that disables bash function imports</a>.
He writes, &#8220;I think that at this point the conservative approach is best, so
until the bash author figures what the best solution is, the feature
is disabled by default for NetBSD. It is not wise to expose bash&#8217;s
parser to the internet and then debug it live while being attacked.&#8221;


<tr><td>2014-09-26 20:33:23Z<td>
<a href="https://svnweb.freebsd.org/ports?view=revision&amp;revision=369341">FreeBSD disables bash function importing from the environment by default</a>,
taking Christos Zoulas&#8217;s approach.

<tr><td>2014-09-26 17:17:09 -0400<td>
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00224.html">Chet Ramey releases official patch 26 for bash 4.3 (the current version),
aka &#8220;bash43-026&#8221;,
along with related patches for past versions of bash</a>.
This resolves the specific vulnerability found by Tavis Ormandy and
reported in CVE-2014-7169, but it
does <i>not</i> fix the underlying problem that the bash parser
is directly exposed to attack.
Any other bash parser error will
continue to be a potential remotely-exploitable dangerous vulnerability
<i>even after this patch is applied</i> if they use the upstream
bash directly.

<tr><td>2014-09-26 18:26:44 -0400<td>
<a href="http://seclists.org/oss-sec/2014/q3/771">David A. Wheeler (the author) posts to oss-sec</a> and
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00240.html">bug-bash</a>:
&#8220;I appreciate the effort made in patch bash43-026, but this patch doesn&#8217;t even
BEGIN to solve the underlying Shellshock problem.
This patch just continues
the &#8216;whack-a-mole&#8217; job of fixing parsing errors
that began with the first patch.
Bash&#8217;s parser is certain [to]
have many many many other vulnerabilities; it
was never designed to be security-relevant!...
This is a really nasty vulnerability; trying to fix the bash
parser with endless whack-a-mole fixes just won&#8217;t cut it...&#8221;
This is one of several posts urging that the bash upstream adopt
a stronger and broader countermeasure.

<tr><td>2014-09-26 23:00 -0400<td>
<a href="http://arstechnica.com/security/2014/09/still-more-vulnerabilities-in-bash-shellshock-becomes-whack-a-mole/">Ars Technica posts
&#8220;Still more vulnerabilities in bash? Shellshock becomes whack-a-mole&#8221;</a>.
This is an example of how closely the media was following
open source software information sources such as the
oss-security and bug-bash mailing lists, because it liberally quoted a
<a href="http://seclists.org/oss-sec/2014/q3/771">post from only
a few hours earlier</a>.

<tr><td>2014-09-27 22:50:07 -0400<td>
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00278.html">Chet Ramey releases official patch 27 for bash 4.3 (the current version),
aka &#8220;bash43-027&#8221;,
along with related patches for past versions of bash</a>.
This accepts Florian Weimer&#8217;s prefix/suffix approach into mainline bash,
fully eliminating the Shellshock problem in the upstream program.
The official version in bash uses prefix &#8220;BASH_FUNC_&#8221; and suffix &#8220;%%&#8221;,
even though Florian&#8217;s original approach used the suffix &#8220;()&#8221; instead.
Wheeler thinks this official bash change
is a mild improvement over Florian&#8217;s original patch;
the sequence &#8220;%%&#8221; has no shell metacharacters,
reducing the risk that it will trigger other problems.
This patch also
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00256.html">tightened the restrictions on allowable imported function names,
requiring them to be shell identifiers</a>.
This is an additional defense; up to this point
dangerous function names like <tt>/bin/echo</tt> had been accepted.
Unfortunately, this breaks several programs;
<a href="https://google-styleguide.googlecode.com/svn/trunk/shell.xml?showone=Function_Names#Function_Names">Google&#8217;s style guide
recommended using :: in function names</a>, and this restriction
broke programs that followed the guidance.

<tr><td>2014-09-28 16:36 +0500<td>
<a href="https://twitter.com/solardiz/status/516370924426514433">Solar Designer tweets a binary patch to bash that eliminates the problem</a>,
and is handy for patching otherwise unmaintained systems.
This is a much quicker way to implement
<a href="https://www.schneier.com/blog/archives/2014/09/nasty_vulnerabi.html#c6679473">Antti Louko&#8217;s approach</a>, and is a helpful
quick fix for some systems.
<a href="http://www.openwall.com/lists/oss-security/2014/09/29/1">Solar Designer
also posted a more detailed description of the patch</a>.
<!--
Twitter HTML source says data-time="1411947396".
This Unix time converts to 09 / 28 / 14 @ 11:36:36pm UTC
-->

<tr><td>2014-09-29<td>
<a href="http://support.apple.com/kb/HT6495">Apple&#8217;s OS X bash update 1.0 includes Florian Weimer&#8217;s approach</a>, with
prefix &#8220;__BASH_FUNC&lt;&#8221; and suffix &#8220;&gt;()&#8221;.
The claimed purpose of the angle brackets is to
&#8220;to prevent unintended function passing via HTTP headers&#8221;,
but I think this not a reasonable justification and their
approach is riskier.
HTTP header field values absolutely <i>can</i>
contain less than and greater than;
<a href="http://tools.ietf.org/html/rfc7230">RFC 7230 section 3.2.6</a>
simply says that they are not allowed in tokens,
but that means that these characters <i>can</i> serve as delimiters.
Angle brackets have special meaning in HTML, of course,
but that&#8217;s different.
I worry that this approach by Apple may have a higher risk because their
prefixes and suffixes include shell metacharacters (and thus might
create a different attack vector).
The source for this date is the Apple page
<a href="http://support.apple.com/kb/DL1769"><i>OS X bash Update 1.0 - OS X Mavericks</i></a>; I have no specific time or timezone information.

<tr><td>2014-10-01 07:21:34 -0700<td>
<a href="http://lists.openwall.net/full-disclosure/2014/10/01/10">Michal Zalewski publicly shares on the fulldisclosure mailing list
the technical details of two previously non-public issues</a>,
CVE-2014-6277 and CVE-2014-6278, which may be
used to circumvent the original patch.
Both were found using the OSS fuzzing tool
<a href="https://code.google.com/p/american-fuzzy-lop">american fuzzy lop</a>.
He also included a much-improved way to test for Shellshock; run
&#8220;<tt>foo='() { echo not patched; }' bash -c foo</tt>&#8221 -
if you see &#8220;not patched&#8221;, upgrade immediately,
and if you see &#8220;bash: foo: command not found&#8221;, you&#8217;re OK.
<!--
Alternate URL:
http://article.gmane.org/gmane.comp.security.fulldisclosure/1038
-->

<tr><td>2014-10-01 07:32:57 -0700<td>
<a href="http://lists.openwall.net/full-disclosure/2014/10/01/11">Paul Vixie posts a refined variation of Michal Zalewski&#8217;s test for Shellshock</a>,
&#8220;<tt>env foo='() { echo not patched; }' bash -c foo</tt>&#8221
(this version directly runs on systems
that use either C shells or Bourne shells).

<tr><td>2014-10-01 10:47:47 -0400<td>
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-10/msg00000.html">Chet Ramey releases official patch 28 for bash 4.3 (the current version),
aka &#8220;bash43-028&#8221;,
along with related patches for past versions of bash</a>.
This is designed to counter the mistakes identified in CVE-2014-7186
and CVE-2014-7187, but these are no longer vulnerabilities in formally-released
bash because patch bash43-027 eliminated the ability to exploit them.

<tr><td>2014-10-02 22:42:53 -0400<td>
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-10/msg00020.html">Chet Ramey releases official patch 29 for bash 4.3 (the current version),
aka &#8220;bash43-029&#8221;,
along with related patches for past versions of bash</a>.
This is designed to counter the mistakes identified in CVE-2014-6277,
but this is no longer a vulnerability in formally-released
bash because patch bash43-027 eliminated the ability to exploit it.

<tr><td>2014-10-05 19:06:06 -0400<td>
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-10/msg00040.html">Chet Ramey releases official patch 30 for bash 4.3 (the current version),
aka &#8220;bash43-030&#8221;,
along with related patches for past versions of bash</a>.
This addresses the specific issue identified in CVE-2014-6278, where a
&#8220;combination of nested command substitutions and function
importing from the environment can cause bash to execute code appearing in
the environment variable value following the function definition&#8221;.
Again, this is no longer a vulnerability in formally-released
bash because patch bash43-027 eliminated the ability to exploit it.

</table>



<h1 id="cves">CVEs</h1>

<p>
There are six CVEs assigned to Shellshock, and there are no
CVEs assigned specifically for the general hardening of bash
as implemented by various distributions and bash patch bash43-027.
This is rather confusing, but this is due to the sequence of events
when the vulnerability was found.
Also, CVEs track <i>vulnerabilities</i>, not <i>solutions</i>
(because better solutions might be found later).
See the previous section on
<a href="#detecting">detecting the Shellshock vulnerability</a>
if that is what you want to do.

<p>
The following list of CVEs, and the bash patches that addressed them,
are based on information from
<a href="http://www.openwall.com/lists/oss-security/2014/10/02/28">Michal Zalewski&#8217;s summary on 2014-10-02</a>,
<a href="http://seclists.org/oss-sec/2014/q4/96">Eric Blake</a>, and
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-10/msg00031.html">Chet Ramey&#8217;s summary on 2014-10-03</a>:

<p>

<ul>
<li>CVE-2014-6271 - original report.  Fixed by bash43-025 (etc.) on 2014-09-24.
<li>CVE-2014-7169 - file creation / token consumption bug found by Tavis.
Fixed by bash43-026 (etc.) on 2014-09-26.
<li>CVE-2014-7186 - 10+ here-doc crash found by Florian and Todd.
Fixed by bash43-028 (etc.) on 2014-10-01.
<li>CVE-2014-7187 - off-by-one parsing error found by Florian.
Fixed by bash43-028 (etc.) on 2014-10-01.
<li>CVE-2014-6277 - uninitialized memory issue found by Michal Zalewski.
Fixed by bash43-029 (etc.) on 2014-10-02.
<li>CVE-2014-6278 - command injection remote command execution (RCE) found by Michal Zalewski.
<a href="https://lists.gnu.org/archive/html/bug-bash/2014-10/msg00040.html">Fixed by bash43-030 (etc.)</a> on 2014-10-05.
</ul>

<p>
Again, all of these are mitigated by
<a href="http://www.openwall.com/lists/oss-security/2014/09/25/13">Florian Weimer&#8217;s patch</a>, a variant of which was accepted upstream by the bash developers on 2014-09-27 via bash43-027 and related patches.
They are also all countered by Christos Zoulas&#8217;s patch
that only imports environment variables
by request (this was the approach used in FreeBSD),
and by the various binary patches that disable function import entirely.
As Zalewski notes, &#8220;If you have
that patch [by Weimer], there&#8217;s no point in obsessing about the status of
individual bugs, because they should no longer pose a security risk.&#8221;


<h1 id="conclusions">Conclusions</h1>

<p>
This paper covered the
<a href="#basics">basics of the Shellshock bash vulnerability</a>
(including <a href="#detecting">how to detect it</a>),
a discussion on ways to
<a href="#detect-or-prevent">detect or prevent future Shellshock-like vulnerabilities</a>,
a <a href="#timeline">timeline</a> of what happened when, and
some information about the specific <a href="#cves">CVEs</a>
(vulnerability identifiers).
<p>
It is <i>much</i> more difficult to detect Shellshock-like vulnerabilities
than other kinds of vulnerabilities - which is a major reason that
it took so long to find!
That said, there are clearly ways to find them, so I hope that
other key programs and libraries that people depend on will be
examined for similar problems.
<p>
If you enjoyed this paper, you might also enjoy the entire
suite of related papers in
my essay suite <a href="learning-from-disaster.html">Learning from Disaster</a>,
which also includes
<a href="heartbleed.html">How to Prevent the next Heartbleed</a> and the
<a href="poodle-sslv3.html">POODLE attack against SSLv3</a>.
My essays
<a href="filenames-in-shell.html">Filenames and Pathnames in Shell: How to do it Correctly</a>, and
<a href="fixing-unix-linux-filenames.html">Fixing Unix/Linux/POSIX Filenames: Control Characters (such as Newline), Leading Dashes, and Other Problems</a>.
discuss filename issues with shell that can lead to security issues.
You might also want to look at my book on
<a href="https://dwheeler.com/secure-programs">how to develop
secure programs</a>.


<p>
<hr>
<p>
Feel free to see my home page at
<a href="https://dwheeler.com">https://dwheeler.com</a>.
You may also want to look at my paper
<a href="https://dwheeler.com/oss_fs_why.html">Why OSS/FS? Look at
the Numbers!</a> and my book on
<a href="https://dwheeler.com/secure-programs">how to develop
secure programs</a>.


<p>
(C) Copyright David A. Wheeler.

</body>
</html>


<!--
Here are some data sources I looked at, not all are used above.

Shellshock: CVE-2014-6271 and CVE-2014-7169

Technical explanation:
http://seclists.org/oss-sec/2014/q3/650


Error in:
http://www.theregister.co.uk/2014/09/24/bash_shell_vuln/
"Robert Graham of Errata Security, who suggested the name Shell Shock for the Bash flaw, also said the programming cock-up is as severe as Heartbleed. But he noted: "There's little need to rush and fix this bug. Your primary servers are probably not vulnerable to this bug...
"However, everything else probably is. Scan your network for things like Telnet, FTP, and old versions of Apache (masscan is extremely useful for this). Anything that responds is probably an old device needing a bash patch. And, since most of them can't be patched, you are likely screwed.
"A lot of wireless routers shell out to ping and traceroute ‚Äì these are all likely vulnerable."
(NOTE: HE DID NOT MAKE THE NAME -
he actually says
"Update: I think people are calling this the "shellshock" bug. Still looking for official logo."

http://ftp.gnu.org/gnu/bash/bash-4.3-patches/bash43-025
Patch to current patch to fix CVE-2014-6271 (but leaves 7169 unresolved).



http://lcamtuf.blogspot.com.es/2014/09/quick-notes-about-bash-bug-its-impact.html
"With that out of the way, it is important to note that the today's patch provided by the maintainer of bash does not stop the shell from trying to parse the code within headers that begin with "() {" - it merely tries to get rid of that particular RCE side effect, originally triggered by appending commands past the end of the actual function def. But even with all the current patches applied, you can still do this:"

http://www.openwall.com/lists/oss-security/2014/09/25/13
More discussion that first patch leaves problem in place.


http://www.zdnet.com/first-attacks-using-shellshock-bash-bug-discovered-7000034044/

https://access.redhat.com/articles/1200223
Working on second patch.
Identifies common cases that they think are affected.


The patch for CVE-2014-6271 is incomplete. An attacker can provide specially-crafted environment variables containing arbitrary commands that will be executed on vulnerable systems under certain conditions. The new issue has been assigned CVE-2014-7169.



http://www.openwall.com/lists/oss-security/2014/09/25/13
Reports that exported functions are used.



http://www.theregister.co.uk/2014/09/24/bash_shell_vuln/
"The vulnerability is present in Bash up to and including version 4.3, and was discovered by Stephane Chazelas. It puts Apache web servers, in particular, at risk of compromise: CGI scripts that use or invoke Bash in any way ‚Äì including any child processes spawned by the scripts ‚Äì are vulnerable to remote-code injection. OpenSSH and some DHCP clients are also affected on machines that use Bash.
Ubuntu and other Debian-derived systems that use Dash exclusively are not at risk ‚Äì Dash isn't vulnerable, but busted versions of Bash may well be present on the systems anyway. It's essential you check the shell interpreters you're using, and any Bash packages you have installed, and patch if necessary."
"The 22-year-old bug, dating back to version 1.13, lies in Bash's handling of environment variables"


Vulnerability found by
"Linux specialist Stephane Schazelas discovered the bug this week, but it's likely existed in the system for at least 20 years."
http://www.nydailynews.com/news/national/shellshock-bug-threatens-mac-linux-computers-article-1.1952516

http://www.wired.com/2014/09/internet-braces-crazy-shellshock-worm/
"Because Shellshock is easy to exploit‚Äîit only takes about three lines of code to attack a vulnerable server - Lackey and other security experts think there‚Äôs a pretty good chance that someone will write a worm code that will jump from vulnerable system to vulnerable system, creating hassles for the world‚Äôs system administrators. "

https://blogs.akamai.com/2014/09/environment-bashing.html


https://en.wikipedia.org/wiki/Shellshock_vulnerability
https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271
http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-7169


https://isc.sans.edu/forums/diary/Update+on+CVE-2014-6271+Vulnerability+in+bash+shellshock+/18707

https://community.qualys.com/blogs/laws-of-vulnerabilities/2014/09/24/bash-shellshock-vulnerability

https://en.wikipedia.org/wiki/Shellshock_%28software_bug%29


http://seclists.org/oss-sec/2014/q3/att-690/eol-pushback.patch

http://seclists.org/oss-sec/2014/q3/659
Re: CVE-2014-6271: remote code execution through bash
From: Florian Weimer <fweimer () redhat com>
Date: Wed, 24 Sep 2014 18:36:16 +0200
...
My main concern with the current patch is that still exposes the bash parser and function definition printer to attacks from the network. Bugs in those fairly large components could cause another critical issue.
For hardening against such issues, I proposed a separate environment variable with a well-known name, say BASH_FUNCDEFS, which lists the names of environment variables which are to be imported as functions. This would bring the attack requirements to the level which we have with BASH_ENV now.
Removing the functionality completely is difficult because it is actually used (search for "export -f").

http://seclists.org/oss-sec/2014/q3/681
Proposal to only inherit functions with lower-case letter names.

http://seclists.org/oss-sec/2014/q3/690
From: Chet Ramey <chet.ramey () case edu>
Date: Wed, 24 Sep 2014 23:01:34 -0400
Here's the patch.  It's not specific to this vulnerability - I can get
it to work from at least one other code path.  Please take a look and
see if you can bypass it.


http://seclists.org/oss-sec/2014/q3/695
From: John Haxby <john.haxby () oracle com>
Date: Thu, 25 Sep 2014 16:17:31 +0100
I worry that simply fixing CVE-2014-6271 and CVE-2014-7129 is just
setting the scene for the next parser problem.


http://www.openwall.com/lists/oss-security/2014/09/25/13
Date: Thu, 25 Sep 2014 14:37:26 +0200
From: Florian Weimer <fweimer@...hat.com>
To: oss-security@...ts.openwall.com
CC: chet.ramey@...e.edu
Subject: Re: CVE-2014-6271: remote code execution through bash

(Only consider env variable names beginning "BASH_FUNC_" and ending "()")


http://seclists.org/oss-sec/2014/q3/759
"The way how bash exports functions is really scary:
1. You can set both variable and export function with same name."



http://seclists.org/oss-sec/2014/q3/748
Re: Re: CVE-2014-6271: remote code execution through bash (3rd vulnerability) From: John Haxby <john.haxby () oracle com>
Date: Fri, 26 Sep 2014 13:47:51 +0100

On 26/09/14 12:33, Florian Weimer wrote:
    On 09/26/2014 10:54 AM, Mark R Bannister wrote:
        Testing patch 25 and 26 from Chet, it looks to me like this is still
        an incomplete fix.  The third vulnerability I'd like to report is the
        feature itself in bash that allows functions to be passed in the
        environment, e.g.
        $ env ls='() { echo vulnerable; }' bash -c ls

        This allows an attacker to replace a command used by a bash script
        with arbitrary code.  It is then down to an attacker to find a
        suitable command that the bash script (or any child shells) might call
        without a path component.

        I can't see this being a problem for Apache custom headers (the
        variable name is turned to uppercase and prefixed by HTTP_), nor sudo
        commands if env_reset is on (the default), but this continues to be a
        major vulnerability for setuid/setgid scripts (S_ISUID or S_ISGID)
        where the environment is preserved.

    I agree this looks scary at first glance, but we discussed this
    previously, see for example:

      <http://www.openwall.com/lists/oss-security/2014/09/24/20>

    Shell scripts derive part of their power and flexibility from their
    openness to the execution environment.  You can tweak PATH, BASH_ENV (or
    ENV for other Bourne-like shells), IFS, HOME, and many other variables
    to change behavior.  There are even more knobs to affect the behavior of
    the external commands almost all shell scripts call when they run.

    This makes them not suitable at all for writing SUID programs or other
    code that runs in untrusted environments.  This is well-documented, and
    given the amount of shell scripts out there which rely on these aspects
    of the UNIX shell design, it's not something we can change, particularly
    not as part of a security update which system administrators are more or
    less forced to install.

    In your specific example, you can achieve the same effect by setting
    PATH to a directory with a customer ls program, or by setting BASH_ENV
    to a file which contains a definition of a function called ls.

    Overriding external programs with shell functions in such a way has to
    be supported.  Otherwise, scripts which define shell functions would
    break if the system administrator installs new software which happens to
    include a program of the same name of the shell function.

It's not so much the known attacks - redefining ls, unset, command,
typeset, declare, etc - it's the future parser bugs that we don't yet
know about.

A friend of mine said this could be a vulnerability gift that keeps on giving.

CVE-2014-7169 was discovered very quickly after CVE-2014-6271.  Do you
think that's the end of it?   (Just in case: I'm not getting at anyone
here, certainly not Chet, Florian or anyone else who has been working
overtime on these.)

Importing functions from the environment is relatively unusual.  I'd
probably go so far as to say very unusual.

Sufficiently unusual, I'd venture, that it should not be done
implicitly.   Florian's "BASH_FUNC_x()" makes it easier to blacklist
these environment variables and ensures that a web server's HTTP_ prefix
will not just create an oddly named function ... is that enough?  Should
bash simply make importing functions something that one has to ask for
explicitly as Christos Zoulas (and others) suggested[1]?

jch





https://svnweb.freebsd.org/ports?view=revision&amp;revision=369341
Disable function importing from the environment by default.  This can be
enabled by using -\-import-functions or enabling the IMPORTFUNCTIONS option.

This removes the risk of further parser bugs leading to code execution, as
well as the risk to setuid scripts and poorly written applications that
do not cleanse their environment [1][2].




Message:  [Protocol-testing] Shellshock bash flaws   [Drag subject to move message] 	[View full headers] [View source] [View print format (Please consider the environment before printing this email)]
Time: 	Fri, 26 Sep 2014 19:54:44 +0000
From: 	"Black, Paul E." <paul.black@nist.gov> [Add to Contacts] 	  [Whitelist sender] [Block sender] [Block domain]
To: 	protocol-testing <protocol-testing@nist.gov>
Subject: 	[Protocol-testing] Shellshock bash flaws
Tags
heartbleed wasn't the end.

-paul-
Paul E. Black             100 Bureau Drive, Stop 8970
paul.black @nist.gov       Gaithersburg, Maryland  20899-8970
voice: +1 301 975-4794    fax: +1 301 975-6097
http://hissa.nist.gov/~black/                        KC7PKT


From: samate-bounces@nist.gov <samate-bounces@nist.gov> on behalf of Stivalet, Bertrand C. <bertrand.stivalet@nist.gov>
Sent: Friday, September 26, 2014 2:44 PM
To: SAMATE
Subject: Re: [Samate] Shellshock bash flaws

Apparently, Stephane Chazelas found the bug after reflecting on an earlier bug he found in Bash a few months ago. To my knowledge, he didn't use specific tools.

Proof of concept that some people are already using the vulnerability:
https://gist.github.com/anonymous/929d622f3b36b00c0be1
http://www.itnews.com.au/News/396197,first-shellshock-botnet-attacks-akamai-us-dod-networks.aspx


Don't forget to patch your system.


-\- Bertrand

On Sep 26, 2014, at 11:17 AM, Athos Ribeiro <athos.ribeiro@nist.gov> wrote:
Hello,

For those who patched bash before yesterday evening, they still had not
fixed the second flaw by then (the patch would fix CVE-2014-6271 but not
CVE-2014-7169). The bug is fixed now and already available in major
GNU/Linux distributions official repositories. One interesting thing is
that Red Hat patched their version of bash with a different patch that
bash developers released.

Does anyone know how the flaw was discovered?

Now, we have been talking about fuzzers, considering the bug has been
there for a while and the exploit is just a few characters long, we
could, as probably everybody else is doing, ask why nobody found about
it earlier. How unlikely would it be for a fuzzer to find the bug?

Athos Ribeiro
Guest Researcher
athos.ribeiro AT nist.gov
Office:      +1 (301) 975-6145
Mobile:      +1 (301) 318-8968

_______________________________________________
Protocol-testing mailing list
Protocol-testing@nist.gov
https://email.nist.gov/mailman/listinfo/protocol-testing




http://www.smh.com.au/it-pro/security-it/stephane-chazelas-the-man-who-found-the-webs-most-dangerous-internet-security-bug-20140927-10mixr.html
Stephane Chazelas: the man who found the web's 'most dangerous' internet security bug
"He said he found the bug after reflecting on an earlier bug he found in Bash a few months ago.
"After some thorough investigation, I reported it with as much information as possible to a few select Linux distribution security lists and Chet Ramey, the Bash maintainer, on September 9," he said."



https://github.com/hannob/bashcheck
test script for Shellshocker and related vulnerabilities
CVE-2014-6271

The original vulnerability.

    https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271

CVE-2014-7169

Further parser error, found by Tavis Ormandy (taviso)

    https://twitter.com/taviso/status/514887394294652929
    https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-7169

CVE-2014-7186

Out of bound memory read error in redir_stack.

    http://seclists.org/oss-sec/2014/q3/712
    https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-7186

CVE-2014-7187

Off-by-one error in nested loops. (check only works when Bash is built with -fsanitize=address)

    http://seclists.org/oss-sec/2014/q3/712
    https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-7187

CVE-2014-6277

Not yet published parser bug by Michal Zalewski (lcamtuf).

    http://lcamtuf.blogspot.de/2014/09/bash-bug-apply-unofficial-patch-now.html
    https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6277




$ example='() { echo hi ; }; echo vulnerable'
$ export example
$ bash
vulnerable


http://arstechnica.com/security/2014/09/shellshock-fixes-beget-another-round-of-patches-as-attacks-mount/



http://support.apple.com/kb/HT6495
Apple applies Florian approach, but with different prefix/suffix:
environment variables that introduce function definitions are required to have a prefix "__BASH_FUNC<" and suffix ">()" to prevent unintended function passing via HTTP headers.


https://lwn.net/Articles/614218/


http://article.gmane.org/gmane.comp.security.fulldisclosure/1038
rom: Michal Zalewski <lcamtuf@...>
Subject: [FD] the other bash RCEs (CVE-2014-6277 and CVE-2014-6278)
Newsgroups: gmane.comp.security.fulldisclosure
Date: 2014-10-01 14:21:34 GMT (1 day, 5 hours and 13 minutes ago)
Note: over the past few days, Florian's patch has been picked up by
major Linux distros (Red Hat, Debian, SUSE, etc), so there is a
reasonable probability that you are in good shape. To test, execute
this command from within a bash shell:
 foo='() { echo not patched; }' bash -c foo
If you see "not patched", you probably want upgrade immediately. If
you see "bash: foo: command not found", you're OK.

Both found using american fuzzy lop:
https://code.google.com/p/american-fuzzy-lop/wiki/AflDoc



Shellshock name coined by Robert Graham of Errata Security
http://www.theregister.co.uk/2014/09/24/bash_shell_vuln/



http://www.openwall.com/lists/oss-security/2014/10/01/1
Tue, 30 Sep 2014 16:59:56 -0700
From: Michal Zalewski <lcamtuf@...edump.cx>
To: oss-security <oss-security@...ts.openwall.com>
Subject: Re: Healing the bash fork

> Finally: *PLEASE* let me know if you have any good ideas on how to find vulnerabilities like this ahead-of-time. My article "How to Prevent the Next Hearbleed" (https://dwheeler.com/essays/heartbleed.html) lists a number of ways that Heartbleed-like vulnerabilities could have been detected ahead-of-time, in ways that are general enough to be useful.  I'd like to do the same with Shellshock, so we can quickly eliminate a whole class of problems.

Well, hindsight is always 20/20. Manual audits and fuzzing would have
had a good likelihood of spotting the bash flaw. In fact, I used a
fairly generic fuzzer to quickly hit three of the four previously
disclosed issues and identify two more. The syntax is terse and the
parser is laid back, which helps. The fault conditions are generic and
intuitive, too - creation of a file, execution of a child process, or
a crash.

But really - all it would have taken is just somebody with un*x
security background reading a book on bash that mentions function
exports (I'm sure there are some); it wouldn't be hard to connect the
dots.

The main problem is that for a very long time, we apparently had no
overlap between these groups. At the face of it, it seemed like
there's absolutely no reason for bash to try to parse generic env
variables. With no convincing reason to study or test the code, nobody
did.
-->

