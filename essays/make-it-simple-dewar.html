<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Make it Simple: A Tale about Robert Dewar</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="A hopefully-inspiring story about Robert Dewar that it's important to rethink software to try to keep it simple">
<meta name="keywords" content="simple, design, software, Ada, GNAT, Robert Dewar, Richard Stallman, compilation model, recompile, dependencies, type-safety">
<meta name="generator" content="vim">
<link rel="stylesheet" type="text/css" href="paper.css">
</head>

<body>

<h1 class="title">Make it Simple: A Tale about Robert Dewar</h1>
<h2 class="author">David A. Wheeler</h2>
<h2 class="date">2015-12-06</h2>

<p>
When designing software, if something looks large or complicated,
try to think of a way of making it simple... possibly
by entirely eliminating components.
It may be much faster to implement, more reliable, and easier to maintain
as a result.
In short: Rethink your problem, and try to make a <b>simple</b> solution.

<p>
That&#8217;s easy to say, but hard to put into practice.
So here&#8217;s a story from the mid-1990s
that most software developers have never heard... it may inspire you.

<!--
The word "specification" has two different meanings in this tale,
so I try to consistently instead use
"language specification" and "spec file".
-->

<p>
<h1 id="problem">The problem</h1>
<p>
My story involves
<a href="https://en.wikipedia.org/wiki/Robert_Dewar">Robert Dewar</a>,
who in the early 1990s
was trying to implement a compiler for the Ada programming language.
Not just any compiler - he wanted to create
a compiler that could be freely used, shared, and modified.
This was generally called Free software; the phrase open source software
(OSS) would not be invented until years later.

<p>
At the time Ada compilers were large, slow, and complex... and as a
result, they were outrageously expensive.
Alsys (the company founded by Ada&#8217;s designer)
sold special extended memory cards for x86 PCs just so people
could run an Ada compiler.
There were a variety of reasons for this.
One was that the language specification seemed to imply that implementations
should have a centralized library for the object files it generated.
In particular, the language specification
required type-safety across an entire program.
<p>
The language specification authors weren&#8217;t crazy;
this requirement prevented some really
dangerous hard-to-debug errors.
It&#8217;s quite possible in C or C++ to modify a header (.h) file,
recompile only <i>some</i> of the files that needed compiling,
and them link them all together into an executable;
the result can be mysterious defects.
The central library according to the language specification
was only a model...  it was generally agreed that there was no
technical <i>requirement</i> that the compiler really have
a central library.
However, it was expected that compilers <i>would</i> work this way
at the time,
since that was the obvious way to ensure type-safety across an entire program.
However, having a central library
meant that Ada compilers had to generate, store, and manage
a central library in some complex intermediate format.

<p>
<h1 id="rethink">The rethink</h1>
<p>
Instead of building an entire compiler from scratch,
Robert Dewar decided to build on an existing good compiler: gcc.
Dewar then had lengthy conversations with Richard Stallman,
gcc&#8217;s original developer.
Richard Stallman believed that Ada&#8217;s type-safety
across-the-program rule did <i>not</i>
need to create order of compilation dependencies
<a href="http://www.ada2012.org/files/Thoughts_on_Ada.pdf">[Gasperoni2012]</a>.
After these discussions
Robert Dewar carefully looked through the language specification
to figure out how to meet the specification by using a more
conventional compilation model... and found a much simpler way to
implement the language specification.

<p>
The GNAT compiler that Dewar co-developed, unlike previous Ada compilers,
simply read source files and generated a single object file.
That was conventional for other languages, but something new for Ada
because of its program-wide type-safety requirement.
There was no centralized library information of any kind; instead,
the &#8220;central library&#8221; was the source code itself
(along with some library information generated by the compiler and
distributed into different files).
The developers still needed to ensure that the 
type-safety was maintained across an entire program,
but they instead did this using
a tiny &#8220;binder&#8221; program that checked timestamps -
implementing the type-safety requirement
in a <i>much</i> simpler manner
<a href="http://dl.acm.org/citation.cfm?id=197708">[Dewar1994]</a>.
This design made the entire compiler much simpler -
all the code for managing a central library
(including saving it, loading it back, and dealing with race conditions)
completely disappeared.
This simplicity also made parallel compilation trivial, and the
race conditions from previous compilers simply couldn&#8217;t happen.

<p>
One problem with this design is that a whole lot of
&#8220;extra&#8221; compilation had to be done compared to how
other Ada compilers did the job.
In this design Ada spec files
(which are similar to C/C++ header files) had to be processed far more
often than in a traditional Ada design.
In previous Ada compilers, an Ada spec file would
only be processed once; in this new design cooked up by Dewar,
spec files had to be processed many times.
Instead of giving up the simplicity of the design,
Dewar and his co-developers
looked for ways to keep the simplicity.

<p>
One of their approaches, which I&#8217;m not sure is documented elsewhere,
is that they hand-optimized the lexer.
The lexer was a small piece of code that directly processes source code.
A lexer is a relatively small routine, so hand-optimizing
a small routine was not a big deal.
What&#8217;s more, the hand-optimization didn&#8217;t make anything else complex;
the hand-optimization was entirely limited to one tiny part of the compiler.
By hand-optimizing a very small part of the program, they
could completely eliminate many other components while maintaining
high performance - a very worthwhile tradeoff.
They also used a hand-coded recursive decent parser for the rest
of the front-end; this did improve performance,
but the main reason they did this was to create dramatically
better error messages.
Page 53 of
<a href="http://dl.acm.org/citation.cfm?doid=197694.197706">[Schonberg1994]</a>
(which describes the compiler design)
states that in the end,
&#8220;given the speed of the front-end [both lexer and parser],
our approach is no less efficient than the conventional [Ada] library
mechanism, and has... important advantages&#8221;.
In short, instead of caching compilation results in a complex central
data store (a central library), they made the compiler
front-end so fast that it was just as fast to recreate the necessary data
from the original sources.
You can see more information on the
<a href="https://en.wikipedia.org/wiki/GNAT">GNAT</a> Wikipedia page.

<p>
<h1 id="aftermath">The aftermath</h1>
<p>
Their result was a compiler that took much less time to implement,
was very fast, and was generally easy to maintain.
Dewar personally told me that when implementing the GNAT compiler,
whenever they looked at the language specification and
thought it might be complicated to implement,
they assumed they didn&#8217;t understand the language specification and
looked for a simpler way to do it.
This mindset that &#8220;there is probably an easy way to do this&#8221;
seems to have been different from others,
who seemed to assume that complexity was always an inevitable part of the job.

<p>
Dewar went on to found the
<a href="http://www.adacore.com/">AdaCore</a>,
a company that over 20 years later
still sells service and support for the Ada compiler and related tools
that are Free/Libre/Open Source Software
(aka &#8220;Freely Licensed Open Source Software&#8221;).
The GNAT Ada compiler is part of the gcc toolsuite, and is
included in the packages of Red Hat and Debian.
Even today, the current version of the compiler he helped write produces
<a href="http://benchmarksgame.alioth.debian.org/u64q/which-programs-are-fastest.html">faster code</a>
than many other compilers.
And of course, Robert Dewar did other things; he was a long advocate
for strong skills in software development, including
knowing multiple programming languages
<a href="http://www.crosstalkonline.org/storage/issue-archives/2008/200801/200801-Dewar.pdf">[Dewar2008]</a>.

<p>
Robert Dewar died from cancer on June 30, 2015,
as noted by both the
<a href="http://cacm.acm.org/news/189582-in-memoriam-robert-dewar-1945-2015/fulltext">ACM</a> and
<a href="http://www.businesswire.com/news/home/20150702005350/en/AdaCore-President-Robert-B.-K.-Dewar-1945-2015#.VZqlke1Vikp">AdaCore</a>.
The world is lesser place without him, but his ideas live on.
In a way, I&#8217;m writing this essay as a tribute to him.

<p>
<h1 id="moral">The moral of the story</h1>
<p>
My point is that whenever you&#8217;re about to write some software,
stop and think about how you can make it simple.
Stop-and-think is especially true if some part
seems complicated, works in an annoyingly different way than
other systems, or is incompatible with other tools you would like to use.
If you&#8217;re creating a whole separate system for managing a database or
fileset, for example, see if there&#8217;s a way you could eliminate it entirely.
If you have to create a special subsystem to manage adding, renaming, and
deleting intermediate components,
and that&#8217;s not the primary purpose of the program, check
to see if there&#8217;s an easier way.
<p>
By rethinking things, you may find a simpler way that
is faster to implement, and results in software that is
more reliable, easier to maintain, and in all other ways better.

<p>
<h1 id="bibliography">Bibliography</h2>
<p>
Unfortunately, many of the important sources are paywalled and thus
inaccessible to most people, but they&#8217;re the only sources I could find.
I am tempted to call paywalled documents &#8220;unpublished&#8221;, because for most
people &#8220;not freely available on the Internet&#8221; has the same effect.
Hopefully in the future more of these materials will become
truly publicly available.

<p>
<a href="http://dl.acm.org/citation.cfm?id=197708">[Dewar1994]</a>
Dewar, Robert.
&#8220;The GNAT compilation model&#8221;.
<a href="http://dblp.uni-trier.de/db/conf/sigada/triada94.html"><i>Proceedings of the conference on TRI-Ada &#8216;94</i></a>.
Pages 58-70.
ACM New York, NY, USA. 1994.
ISBN:0-89791-666-2.
<a href="http://dl.acm.org/citation.cfm?id=197708">http://dl.acm.org/citation.cfm?id=197708</a>

<p>
<a href="http://www.crosstalkonline.org/storage/issue-archives/2008/200801/200801-Dewar.pdf">[Dewar2008]</a>).
Dewar, Robert and Edmond Schonberg.
&#8220;Computer Science Education:
Where Are the Software Engineers of Tomorrow?&#8221;
Crosstalk.
2008.
<a href="http://www.crosstalkonline.org/storage/issue-archives/2008/200801/200801-Dewar.pdf">http://www.crosstalkonline.org/storage/issue-archives/2008/200801/200801-Dewar.pdf</a>

<p>
<a href="http://www.ada2012.org/files/Thoughts_on_Ada.pdf">[Gasperoni2012]</a>
<i>Thoughts on Ada and Language Technology in Our Times.</i>
Franco Gasperoni (AdaCore).
2012.
<a href="http://www.ada2012.org/files/Thoughts_on_Ada.pdf">http://www.ada2012.org/files/Thoughts_on_Ada.pdf</a>

<p>
<a href="http://dl.acm.org/citation.cfm?doid=197694.197706">[Schonberg1994]</a>.
Edmond Schonberg and Bernard Banner.
&#8220;The GNAT project: a GNU-Ada 9X compiler&#8221;.
<a href="http://dblp.uni-trier.de/db/conf/sigada/triada94.html"><i>Proceedings of the conference on TRI-Ada &#8216;94</i></a>.
Pages 48-57.
ACM New York, NY, USA. 1994.
ISBN:0-89791-666-2.
<a href="http://dl.acm.org/citation.cfm?doid=197694.197706">http://dl.acm.org/citation.cfm?doid=197694.197706</a>

<p>
<hr>
<p>
Feel free to see my home page at
<a href="https://dwheeler.com">https://dwheeler.com</a>.
You may also want to look at my paper
<a href="https://dwheeler.com/oss_fs_why.html">Why OSS/FS? Look at
the Numbers!</a> and my book on
<a href="https://dwheeler.com/secure-programs">how to develop
secure programs</a>.

<p>
(C) Copyright 2015 David A. Wheeler.
Released under
<a href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons
Attribution-ShareAlike version 3.0 or later
(CC-BY-SA-3.0+)</a>.

</body>
</html>

