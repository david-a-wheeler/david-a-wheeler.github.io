<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.dwheeler.com/blog/index.rss"></link>
<title>David A. Wheeler's Blog   </title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<h1 style="margin-left: auto; margin-right: auto; width: 50%;">David A. Wheeler's Blog</h1><p>  </p><p></p><h1>Mon, 05 Nov 2007</h1>
<p><a name="high-assurance-floss-components"><font size="+2"><b>Please point me to High-Assurance Free-Libre / Open Source Software (FLOSS) Components</b></font></a></p><p></p>
<p>
I&#8217;m looking for
<a href="http://www.dwheeler.com/essays/high-assurance-floss.html#highassurancecomponents">High Assurance and Free-Libre / Open Source Software (FLOSS) components</a>.
Can anyone <a href="http://www.dwheeler.com/contactme.html">point me to ones I don&#8217;t know about</a>?
A little context might help, I suppose&#8230;
</p>
<p>
A while back I posted a paper,
<a href="http://www.dwheeler.com/essays/high-assurance-floss.html">High Assurance (for Security or Safety) and Free-Libre / Open Source Software (FLOSS)</a>.
For purposes of the paper,
I define &#8220;high assurance software&#8221;
as software where there&#8217;s an <i>argument
that could convince skeptical parties</i>
that the software <i>will always perform or never perform</i>
certain key functions <i>without fail</i>.
That means you have to show convincing evidence that there are
<i>absolutely no software defects</i>
that would interfere with the software&#8217;s key functions.
Almost all software built today is <i>not</i> high assurance;
developing high assurance software is currently a specialist&#8217;s field.
</p>
<p>
High assurance and FLOSS are potentially a great match.
We achieve high assurance in scientific analysis and
mathematical proofs by subjecting them to peer review, and then
worldwide review.
FLOSS programs, unlike proprietary programs, can receive similar kinds of
review, and many FLOSS programs achieve
really good reliability figures for medium assurance.
So it can be easily argued that
stepping up to high assurance should be <i>easier</i> for
FLOSS than for proprietary software.
In addition, there are a vast number of FLOSS tools that support developing
high assurance components,
including PVS, ACL2, Isabelle/HOL, prover9, and Alloy
(there&#8217;s lots more, see the paper for more details).
</p>
<p>
Yet it&#8217;s hard to find
<a href="http://www.dwheeler.com/essays/high-assurance-floss.html#highassurancecomponents">High Assurance Free-Libre / Open Source Software (FLOSS) components</a>.
To be fair, high assurance software components
are exceedingly rare in the non-FLOSS world as well.
But I suspect there are more than I&#8217;ve found, and I hope that people
will help me by pointing them out to me.
I&#8217;d like to know about such components for direct use, and also simply for
use as demonstrations of how to actually develop high assurance software.
Today, it&#8217;s nearly impossible to explain how to develop high assurance
software, because there are almost no fully-published examples.
Existing &#8220;formal methods successes&#8221; papers generally
don&#8217;t publish everything including their specs, proofs, and code&#8230;
which makes it impossible to really learn how to do it.
And no, I don&#8217;t <i>require</i> that proofs prove every line of machine code;
but showing how correspondance demonstrations are made would be valuable,
and that&#8217;s currently not well demonstrated by working examples.
</p>
<p>
If you&#8217;re curious about the general topic, take a peek at <a href="http://www.dwheeler.com/essays/high-assurance-floss.html">High Assurance (for Security or Safety) and Free-Libre / Open Source Software (FLOSS)</a>.
I&#8217;ve collected lots of interesting information;
hopefully it will be useful to some of you.
And <a href="http://www.dwheeler.com/contactme.html">let me know</a> of
high-assurance FLOSS components that I don&#8217;t already know about.
</p>
<p>path: <a href="http://www.dwheeler.com/blog/oss">/oss</a> | <a href="http://www.dwheeler.com/blog">Current Weblog</a> | <a href="http://www.dwheeler.com/blog/2007/11/05#high-assurance-floss-components">permanent link to this entry</a></p>
<h1>Sun, 04 Nov 2007</h1>
<p><a name="mapreduce"><font size="+2"><b>Added &#8220;MapReduce&#8221; to the &#8220;Software Innovations&#8221; list</b></font></a></p><p></p>
<p>
<a href="http://blog.krugle.com/?p=272">Ken Krugler&#8217;s recent blog</a>
said that my article of
<a href="http://www.dwheeler.com/innovation/innovation.html">
The Most Important Software Innovations</a> was &#8220;very good&#8221;, but he
was surprised that I hadn&#8217;t included
<a href="http://labs.google.com/papers/mapreduce.html">MapReduce</a>
as an important software innovation.
Basically, MapReduce makes writing certain kinds of
programs that process <i>huge</i> amounts of data, on vast distributed
clusters, remarkably easy and efficient.
(<a href="http://en.wikipedia.org/wiki/MapReduce">Wikipedia explains
MapReduce</a>, including links to alternative implementations like
the open source <a href="http://lucene.apache.org/hadoop/">Hadoop</a>.)
</p>
<p>
It&#8217;s not because I didn&#8217;t know about MapReduce;
I read about it almost immediately after it got published.
I thought it was <i>very</i> promising, and even forwarded the original
paper to some co-workers.
I think MapReduce is especially promising because, now that we have
cheap commodity computers, having a way to <i>easily</i> exploit their
capabilities is really valuable.
But even with something this promising, I didn&#8217;t want to add it to
my list of innovations right away - after all,
maybe after a little while it turns out to be not so helpful.
</p>
<p>
Currently, there&#8217;s aren&#8217;t many who have Google-sized clusters of computers
available.
But it&#8217;s clear that this approach is useful in many other circumstances
as well.
It&#8217;s new, but I think it&#8217;s stood the test of time enough that it&#8217;s
a worthy addition&#8230; so I&#8217;ve just added it.
</p>
<p>
One interesting issue is that the
MapReduce framework is itself built primarily on
the &#8220;map&#8221; and &#8220;reduce&#8221; functions, which are far, far older.
So, is MapReduce really a <i>new</i> idea,
or is it just a high-quality implementation of an old idea?
I&#8217;ll accept that it&#8217;s a new idea, but that can be difficult to judge.
This judgment doesn&#8217;t <i>really</i> matter unless you think
software patents are a good idea
(since every software patents in theory prevents progress for 20 years).
But I think it&#8217;s quite clear that software patents are a foolish idea,
and it&#8217;s clear that others have come to the same conclusion.
<a href="http://press.ffii.org/Press_releases/Economist_Critic_of_Software_Patents_gets_Nobel_Prize">
Eric S. Maskin, an economist who has long criticised the patenting
of software, recently received the 2007 Nobel Prize for Economics</a>.
Here&#8217;s a nice quote:
&#8220;&#8230; when patent protection was extended to software in the 1980s,
[&#8230;] standard arguments would predict that R&amp;D
intensity and productivity should have increased among patenting firms.
Consistent with our model, however, these increases did not occur.&#8221;
Someone who correctly predicted that software patents were harmful
to innovation just received a Nobel prize.
I hope to someday see people receive other prizes because they
ended software patenting in the United States.
</p>
<p>path: <a href="http://www.dwheeler.com/blog/misc">/misc</a> | <a href="http://www.dwheeler.com/blog">Current Weblog</a> | <a href="http://www.dwheeler.com/blog/2007/11/04#mapreduce">permanent link to this entry</a></p>
</body></html>