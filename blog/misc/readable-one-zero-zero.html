<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.dwheeler.com/blog/index.rss"></link>
<title>David A. Wheeler's Blog   </title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<h1 style="margin-left: auto; margin-right: auto; width: 50%;">David A. Wheeler's Blog</h1><p>  </p><p></p><h1>Mon, 14 Oct 2013</h1>
<p><a name="readable-one-zero-zero"><font size="+2"><b>Readable Lisp version 1.0.0 released!</b></font></a></p><p></p>
<p>
Lisp-based languages have been around a long time.
They have some interesting properties, especially when you
want to write programs that analyze or manipulate programs.
The problem with Lisp is that the traditional Lisp notation -
<i>s-expressions</i> - is notoriously hard to read.
</p>

<p>
I think I have a solution to the problem.
I looked at past (failed) solutions and found that they generally
failed to be <i>general</i> or <i>homoiconic</i>.
I then worked to find notations with these key properties.
My solution is a set of notation tiers that
make Lisp-based languages much more pleasant to work with.
I&#8217;ve been working with many others to turn this idea of readable
notations into a reality.
If you&#8217;re interested, you can
<a href="http://readable.sourceforge.net/">watch a short video</a> or
<a href="http://sourceforge.net/p/readable/wiki/Solution/">read
our proposed solution</a>.
</p>

<p>
The big news is that we have
<a href="https://sourceforge.net/projects/readable/files/">reached
version 1.0.0 in the readable project</a>.
We now have an open source software (MIT license) implementation for
both (guile) Scheme and Common Lisp, as well as a variety of
support tools.
The Scheme portion implements the
<a href="http://srfi.schemers.org/srfi-105/">SRFI-105</a> and
<a href="http://srfi.schemers.org/srfi-110/">SRFI-110</a> specs,
which we wrote.
One of the tools, unsweeten, makes it possible to process files in
other Lisps as well.
</p>

<p>
So what do these tools do?
Fundamentally, they implement the 3 notation tiers we&#8217;ve created:
curly-infix-expressions, neoteric-expressions, and sweet-expressions.
Sweet-expressions have the full set of capabilities.
</p>

<p>
Here&#8217;s an example of (awkward) traditional s-expression format:
<pre>
(define (factorial n)
  (if (&lt;= n 1)
    1
    (* n (factorial (- n 1)))))
</pre>
</p>

<p>
Here&#8217;s the same thing, expressed using sweet-expressions:
<pre>
define factorial(n)
  if {n &lt;= 1}
    1
    {n * factorial{n - 1}}
</pre>
</p>

<p>
I even briefly mentioned sweet-expressions in my
<a href="http://www.dwheeler.com/trusting-trust/">PhD dissertation
&#8220;Fully Countering Trusting Trust through Diverse Double-Compiling&#8221;</a>
(see section A.3).
</p>

<p>
So if you are interested in how to make Lisp-based languages
easier to read,
<a href="http://readable.sourceforge.net/">watch our short video about the readable notations</a>
or 
<a href="https://sourceforge.net/projects/readable/files/">download
the current version of the readable project</a>.
We hope you enjoy them.
</p>
<p>path: <a href="http://www.dwheeler.com/blog/misc">/misc</a> | <a href="http://www.dwheeler.com/blog">Current Weblog</a> | <a href="http://www.dwheeler.com/blog/2013/10/14#readable-one-zero-zero">permanent link to this entry</a></p>
</body></html>