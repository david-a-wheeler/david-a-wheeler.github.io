<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.dwheeler.com/blog/index.rss"></link>
<title>David A. Wheeler's Blog   </title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<h1 style="margin-left: auto; margin-right: auto; width: 50%;">David A. Wheeler's Blog</h1><p>  </p><p></p><h1>Wed, 21 Aug 2013</h1>
<p><a name="open-security"><font size="+2"><b>Open security</b></font></a></p><p></p>
<p>
Modern society depends on computer systems.
Yet computer security problems let attackers subvert the very systems
that society depends on.
This is a serious problem.
</p>
<p>
I think one approach that could help is
<a href="http://www.dwheeler.com/essays/open-security-definition.html">
&#8220;open security&#8221;</a> -
applying open source software (OSS)
approaches to help solve computer security problems.
To see why, let&#8217;s look at some background.
</p>
<p>
Back in the 1970s people collaboratively developed software
that today we would call open source software or free-libre software.
At the time many assumed these approaches could not scale up
to big systems&#8230; but they were wrong.
<a href="http://www.dwheeler.com/sloc">Software systems
that would cost over a billion U.S. dollars to redevelop</a>
have been developed as open source software, and
Wikipedia has used similar approaches to collaboratively develop
the world&#8217;s largest encyclopedia.
</p>
<p>
So&#8230; if we can collaboratively develop multi-billion software systems,
and large encyclopedias, can we use the same kinds of collaborative
approaches to improve computer security?
I believe we can&#8230; but if we are going to do this, we need to
define a term for this (so that we can agree on what we are doing!).
</p>

<p>
I propose that
<i>open security is the application of open source software (OSS)
approaches to help solve cyber security problems</i>.
OSS approaches
collaboratively develop and maintain intellectual works (including
software and documentation) by enabling users to use them for any
purpose, as well as study, create, change, and redistribute them (in
whole or in part).
Cyber security problems are a lack of security
(confidentiality, integrity, and/or availability), or potential lack of
security (a vulnerability), in computer systems and/or the networks they
are a part of.
In short, open security improves <i>security</i> through <i>collaboration.</i>
</p>

<p>
You can see more details in my paper
<a href="http://www.dwheeler.com/essays/open-security-definition.html">What is open security?</a>
<a href="http://www.dwheeler.com/essays/open-security-definition.pdf">[PDF]</a>
<a href="http://www.dwheeler.com/essays/open-security-definition.doc">[DOC]</a>.
I intentionally built on previous work such as the
<a href="http://www.gnu.org/philosophy/free-sw.html"><i>Free Software Definition</i> by the Free Software Foundation (FSF)</a>,
the <a href="http://opensource.org/osd-annotated"><i>Open Source Definition (Annotated)</i> by the Open Source Initiative (OSI)</a>,
the <a href="http://creativecommons.org/licenses/">Creative Commons license work</a>, and the
<a href="http://freedomdefined.org/Definition"><i>Definition of Free Cultural Works</i> by Freedom Defined</a>
(the last one is, for example, the basis of the
<a href="http://wikimediafoundation.org/wiki/Resolution:Licensing_policy">Wikimedia/Wikipedia licensing policy</a>).
</p>

<p>
The <a href="http://open-sec.org/">Open security site</a>
has been recently set up so that you and others can join and get involved.
So please - get involved!
We are only just starting, and the direction we go depends
on the feedback we get.
</p>

<p>
Further reading:
</p>
<ul>
<li><a href="http://open-sec.org/">Open security site</a></li>
<li><a href="http://www.dwheeler.com/essays/open-security-definition.html">What is open security?</a></li>
</ul>
<p>path: <a href="http://www.dwheeler.com/blog/oss">/oss</a> | <a href="http://www.dwheeler.com/blog">Current Weblog</a> | <a href="http://www.dwheeler.com/blog/2013/08/21#open-security">permanent link to this entry</a></p>
<h1>Tue, 06 Aug 2013</h1>
<p><a name="anthropomorphism"><font size="+2"><b>Don&#8217;t anthropomorphize computers, they hate that</b></font></a></p><p></p>
<p>
A lot of people who program computers or live in the computing world &dash;
including me &dash;
talk about computer hardware and software as if they are people.
Why is that?
This is not as obvious as you&#8217;d think.
</p>

<p>
After all, if you read the literature about learning how to program,
you&#8217;d think that programmers
would <i>never</i> use anthropomorphic language.
<a href="http://www.codinghorror.com/blog/2006/07/separating-programming-sheep-from-non-programming-goats.html">
&#8220;Separating Programming Sheep from Non-Programming Goats&#8221;
by Jeff Atwood</a>
discusses teaching programming and points to the
intriguing paper
<a href="http://www.eis.mdx.ac.uk/research/PhDArea/saeed/paper1.pdf">
&#8220;The camel has two humps&#8221; by
Saeed Dehnadi and Richard Bornat</a>.
This paper reported experimental evidence on why
some people can learn to program, while others struggle.
Basically, to learn to program you must fully understand
that computers mindlessly follow rules, and that
computers just don&#8217;t act like humans.
As their paper said,
&#8220;Programs&#8230; are utterly meaningless.
To write a computer program you have to come to terms with this,
to accept that whatever you might want the program to mean,
the machine will blindly follow its meaningless rules and come to
some meaningless conclusion&#8230;
the consistent group [of people] showed a pre-acceptance of this fact:
they are capable of seeing mathematical calculation problems
in terms of rules, and can follow those rules wheresoever they may lead.
The inconsistent group, on the other hand, looks for meaning
where it is not.
The blank group knows that it is looking at meaninglessness,
and refuses to deal with it.
[The experimental results suggest] that it is extremely difficult
to teach programming to the inconsistent and blank groups.&#8221;
<a href="http://www.eis.mdx.ac.uk/research/PhDArea/saeed/">
Later work by Saeed Dehnadi and sometimes others</a>
expands on this earlier work.
<!-- "Testing Programming Aptitude" -->
The intermediate paper
&#8220;Mental models, Consistency and Programming Aptitude&#8221; (2008)
seemed to have refuted the idea that consistency
(and ignoring meaning) was critical to programming, but the later
<a href="http://www.eis.mdx.ac.uk/research/PhDArea/saeed/SD_PPIG_2009.pdf">
&#8220;Meta-analysis of the effect of consistency on success
in early learning of programming&#8221; (2009)</a>
added additional refinements and then re-confirmed this hypothesis.
The reconfirmation involved a meta-analysis of
six replications of an improved version of Dehnadi&#8217;s
original experiment, and again showed that understanding that computers were
mindlessly consistent was key in successfully learning to program.
</p>

<p>
So the good programmers know darn well that computers mindlessly
follow rules.
But many use anthropomorphic language anyway.
Huh?
Why is that?
</p>

<p>
Some do object to anthropomorphism, of course.
<a href="http://lambda-the-ultimate.org/node/264">Edjar Dijkstra
certainly railed against anthropomorphizing computers</a>.
For example,
in <a href="http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD854.PDF">EWD854</a>
(1983) he said,
&#8220;I think anthropomorphism is the worst of all [analogies].
I have now seen programs &#8216;trying to do things&#8217;, &#8216;wanting to do things&#8217;,
&#8216;believing things to be true&#8217;, &#8216;knowing things&#8217; etc.
Don&#8217;t be so naive as to believe that this use of language is harmless.&#8221;
He believed that analogies (like these) led to a host of misunderstandings,
and that those misunderstandings led to repeated
multi-million-dollar failures.
It is certainly true that misunderstandings can lead to catastrophe.
But I think one reason Dijkstra railed particularly against anthropomorphism
was (in part) because it is a widespread practice, even among those
who <i>do</i> understand things &dash;
and I see no evidence that anthropomorphism is going away.
</p>

<p>
The
<a href="http://www.catb.org/jargon/html/anthropomorphization.html">
Jargon file specifically discusses anthropomorphization</a>:
&#8220;one rich source of jargon constructions is the hackish tendency
to anthropomorphize hardware and software. English purists and
academic computer scientists frequently look down on others for
anthropomorphizing hardware and software, considering this sort of
behavior to be characteristic of naive misunderstanding.
But most hackers anthropomorphize freely,
frequently describing program behavior in terms of wants and desires.
Thus it is common to hear hardware or software talked about as though
it has homunculi talking to each other inside it, with intentions and
desires&#8230;
As hackers are among the people
who know best how these phenomena work, it seems odd that they would
use language that seems to ascribe consciousness to them. The mind-set
behind this tendency thus demands examination.
The key to understanding this kind of usage is that it isn&#8217;t done in
a naive way; hackers don&#8217;t personalize their stuff in the sense of
feeling empathy with it, nor do they mystically believe that the things
they work on every day are &#8216;alive&#8217;.&#8221;
</p>

<p>
Okay, so others have noticed this too.
The
<a href="http://www.catb.org/jargon/html/anthropomorphization.html">
Jargon file even proposes some possible reasons for anthropomorphizing
computer hardware and software</a>:
</p>

<ol>
<li>It reflects a &#8220;mechanistic view of human behavior.&#8221;
&#8220;In this view, people are biological
machines - consciousness is an interesting and valuable epiphenomenon,
but mind is implemented in machinery which is not fundamentally different
in information-processing capacity from computers&#8230;
Because hackers accept that a human machine can have intentions, it
is therefore easy for them to ascribe consciousness and intention to
other complex patterned systems such as computers.&#8221;
But while the materialistic view of humans has respectible company,
this &#8220;explanation&#8221; fails to explain
why humans would use anthropomorphic
terms about computer hardware and software,
since they are manifestly not human.
Indeed, as the Jargon file acknowledges,
even hackers who have contrary religious views will use
anthropological terminology.
</li>
<li>
It reflects
&#8220;a blurring of the boundary between the programmer and
his artifacts - the human qualities belong to the programmer and the
code merely expresses these qualities as his/her proxy. On this view,
a hacker saying a piece of code &#8216;got confused&#8217; is really saying that
he (or she) was confused about exactly what he wanted the computer to do,
the code naturally incorporated this confusion, and the code expressed the
programmer&#8217;s confusion when executed by crashing or otherwise misbehaving.
Note that by displacing from &#8220;I got confused&#8221; to
&#8220;It got confused&#8221;, the programmer is not avoiding responsibility,
but rather getting some analytical distance in order
to be able to consider the bug dispassionately.&#8221;
</li>
<li>
&#8220;It has also been suggested that anthropomorphizing complex systems is
actually an expression of humility, a way of acknowleging that simple
rules we do understand (or that we invented) can lead to emergent
behavioral complexities that we don&#8217;t completely understand.&#8221;
</li>
</ol>

<p>
The Jargon file claims that
&#8220;All three explanations accurately model hacker psychology, and should
be considered complementary rather than competing.&#8221;
I think the first &#8220;explanation&#8221; is completely unjustified.
The second and third explanations do have some merit.
However, I think there&#8217;s a simpler and more important reason: Language.
</p>

<p>
When we communicate with a human, we must use some language that will be
more-or-less understood by the other human.
Over the years people have developed a variety of human languages
that do this pretty well (again, more-or-less).
Human languages were not particularly designed to deal with computers,
but languages <i>have</i> been honed over long periods of time
to discuss human behaviors and their mental states
(thoughts, beliefs, goals, and so on).
The sentence
&#8220;Sally says that Linda likes Tom,
but Tom won&#8217;t talk to Linda&#8221;
would be understood by any normal seven-year-old girl
(well, assuming she speaks English).
</p>

<p>
I think a primary reason people anthropomorphic terminology
is because it&#8217;s much easier to communicate that way
when discussing computer hardware and software using existing languages.
Compare &#8220;the program got confused&#8221; with
the overly long
&#8220;the program executed a different path than the one expected by the
program&#8217;s programmer&#8221;.
Human languages have been honed to discuss human behaviors and
mental states, so it is much easier to use languages this way.
As long as both the sender and receiver of the message understand the
message, the fact that the terminology is anthropomorphic is
not a problem.
</p>

<p>
It&#8217;s true that anthropomorphic language can confuse some people.
But the primary reason it confuses some people is that they
still have trouble understanding that computers are mindless &dash;
that computers simply do whatever their instructions tell them.
Perhaps this is an innate weakness in some people,
but I think that addressing this weakness head-on
can help counter it.
This is probably a good reason for ensuring that people learn
a little programming as kids &dash; not because they will
necessarily do it later, but because computers are so central
to the modern world that people should have a basic understanding of them.
</p>
<p>path: <a href="http://www.dwheeler.com/blog/misc">/misc</a> | <a href="http://www.dwheeler.com/blog">Current Weblog</a> | <a href="http://www.dwheeler.com/blog/2013/08/06#anthropomorphism">permanent link to this entry</a></p>
</body></html>